// Generated by dts-bundle-generator v9.5.1

type Primitive = string | number | symbol | bigint | boolean | null | undefined;
type Scalars = Primitive | Primitive[];
declare namespace util {
	type AssertEqual<T, U> = (<V>() => V extends T ? 1 : 2) extends <V>() => V extends U ? 1 : 2 ? true : false;
	export type isAny<T> = 0 extends 1 & T ? true : false;
	export const assertEqual: <A, B>(val: AssertEqual<A, B>) => AssertEqual<A, B>;
	export function assertIs<T>(_arg: T): void;
	export function assertNever(_x: never): never;
	export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
	export type OmitKeys<T, K extends string> = Pick<T, Exclude<keyof T, K>>;
	export type MakePartial<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;
	export type Exactly<T, X> = T & Record<Exclude<keyof X, keyof T>, never>;
	export const arrayToEnum: <T extends string, U extends [
		T,
		...T[]
	]>(items: U) => {
		[k in U[number]]: k;
	};
	export const getValidEnumValues: (obj: any) => any[];
	export const objectValues: (obj: any) => any[];
	export const objectKeys: ObjectConstructor["keys"];
	export const find: <T>(arr: T[], checker: (arg: T) => any) => T | undefined;
	export type identity<T> = objectUtil.identity<T>;
	export type flatten<T> = objectUtil.flatten<T>;
	export type noUndefined<T> = T extends undefined ? never : T;
	export const isInteger: NumberConstructor["isInteger"];
	export function joinValues<T extends any[]>(array: T, separator?: string): string;
	export const jsonStringifyReplacer: (_: string, value: any) => any;
	export {};
}
declare namespace objectUtil {
	export type MergeShapes<U, V> = keyof U & keyof V extends never ? U & V : {
		[k in Exclude<keyof U, keyof V>]: U[k];
	} & V;
	type optionalKeys<T extends object> = {
		[k in keyof T]: undefined extends T[k] ? k : never;
	}[keyof T];
	type requiredKeys<T extends object> = {
		[k in keyof T]: undefined extends T[k] ? never : k;
	}[keyof T];
	export type addQuestionMarks<T extends object, _O = any> = {
		[K in requiredKeys<T>]: T[K];
	} & {
		[K in optionalKeys<T>]?: T[K];
	} & {
		[k in keyof T]?: unknown;
	};
	export type identity<T> = T;
	export type flatten<T> = identity<{
		[k in keyof T]: T[k];
	}>;
	export type noNeverKeys<T> = {
		[k in keyof T]: [
			T[k]
		] extends [
			never
		] ? never : k;
	}[keyof T];
	export type noNever<T> = identity<{
		[k in noNeverKeys<T>]: k extends keyof T ? T[k] : never;
	}>;
	export const mergeShapes: <U, T>(first: U, second: T) => T & U;
	export type extendShape<A extends object, B extends object> = keyof A & keyof B extends never ? A & B : {
		[K in keyof A as K extends keyof B ? never : K]: A[K];
	} & {
		[K in keyof B]: B[K];
	};
	export {};
}
declare const ZodParsedType: {
	string: "string";
	number: "number";
	bigint: "bigint";
	boolean: "boolean";
	symbol: "symbol";
	undefined: "undefined";
	object: "object";
	function: "function";
	map: "map";
	nan: "nan";
	integer: "integer";
	float: "float";
	date: "date";
	null: "null";
	array: "array";
	unknown: "unknown";
	promise: "promise";
	void: "void";
	never: "never";
	set: "set";
};
type ZodParsedType = keyof typeof ZodParsedType;
declare const getParsedType: (data: any) => ZodParsedType;
type allKeys<T> = T extends any ? keyof T : never;
type inferFlattenedErrors<T extends ZodType<any, any, any>, U = string> = typeToFlattenedError<TypeOf<T>, U>;
type typeToFlattenedError<T, U = string> = {
	formErrors: U[];
	fieldErrors: {
		[P in allKeys<T>]?: U[];
	};
};
declare const ZodIssueCode: {
	invalid_type: "invalid_type";
	invalid_literal: "invalid_literal";
	custom: "custom";
	invalid_union: "invalid_union";
	invalid_union_discriminator: "invalid_union_discriminator";
	invalid_enum_value: "invalid_enum_value";
	unrecognized_keys: "unrecognized_keys";
	invalid_arguments: "invalid_arguments";
	invalid_return_type: "invalid_return_type";
	invalid_date: "invalid_date";
	invalid_string: "invalid_string";
	too_small: "too_small";
	too_big: "too_big";
	invalid_intersection_types: "invalid_intersection_types";
	not_multiple_of: "not_multiple_of";
	not_finite: "not_finite";
};
type ZodIssueCode = keyof typeof ZodIssueCode;
type ZodIssueBase = {
	path: (string | number)[];
	message?: string;
};
interface ZodInvalidTypeIssue extends ZodIssueBase {
	code: typeof ZodIssueCode.invalid_type;
	expected: ZodParsedType;
	received: ZodParsedType;
}
interface ZodInvalidLiteralIssue extends ZodIssueBase {
	code: typeof ZodIssueCode.invalid_literal;
	expected: unknown;
	received: unknown;
}
interface ZodUnrecognizedKeysIssue extends ZodIssueBase {
	code: typeof ZodIssueCode.unrecognized_keys;
	keys: string[];
}
interface ZodInvalidUnionIssue extends ZodIssueBase {
	code: typeof ZodIssueCode.invalid_union;
	unionErrors: ZodError[];
}
interface ZodInvalidUnionDiscriminatorIssue extends ZodIssueBase {
	code: typeof ZodIssueCode.invalid_union_discriminator;
	options: Primitive[];
}
interface ZodInvalidEnumValueIssue extends ZodIssueBase {
	received: string | number;
	code: typeof ZodIssueCode.invalid_enum_value;
	options: (string | number)[];
}
interface ZodInvalidArgumentsIssue extends ZodIssueBase {
	code: typeof ZodIssueCode.invalid_arguments;
	argumentsError: ZodError;
}
interface ZodInvalidReturnTypeIssue extends ZodIssueBase {
	code: typeof ZodIssueCode.invalid_return_type;
	returnTypeError: ZodError;
}
interface ZodInvalidDateIssue extends ZodIssueBase {
	code: typeof ZodIssueCode.invalid_date;
}
type StringValidation = "email" | "url" | "emoji" | "uuid" | "nanoid" | "regex" | "cuid" | "cuid2" | "ulid" | "datetime" | "date" | "time" | "duration" | "ip" | "cidr" | "base64" | "jwt" | "base64url" | {
	includes: string;
	position?: number;
} | {
	startsWith: string;
} | {
	endsWith: string;
};
interface ZodInvalidStringIssue extends ZodIssueBase {
	code: typeof ZodIssueCode.invalid_string;
	validation: StringValidation;
}
interface ZodTooSmallIssue extends ZodIssueBase {
	code: typeof ZodIssueCode.too_small;
	minimum: number | bigint;
	inclusive: boolean;
	exact?: boolean;
	type: "array" | "string" | "number" | "set" | "date" | "bigint";
}
interface ZodTooBigIssue extends ZodIssueBase {
	code: typeof ZodIssueCode.too_big;
	maximum: number | bigint;
	inclusive: boolean;
	exact?: boolean;
	type: "array" | "string" | "number" | "set" | "date" | "bigint";
}
interface ZodInvalidIntersectionTypesIssue extends ZodIssueBase {
	code: typeof ZodIssueCode.invalid_intersection_types;
}
interface ZodNotMultipleOfIssue extends ZodIssueBase {
	code: typeof ZodIssueCode.not_multiple_of;
	multipleOf: number | bigint;
}
interface ZodNotFiniteIssue extends ZodIssueBase {
	code: typeof ZodIssueCode.not_finite;
}
interface ZodCustomIssue extends ZodIssueBase {
	code: typeof ZodIssueCode.custom;
	params?: {
		[k: string]: any;
	};
}
type DenormalizedError = {
	[k: string]: DenormalizedError | string[];
};
type ZodIssueOptionalMessage = ZodInvalidTypeIssue | ZodInvalidLiteralIssue | ZodUnrecognizedKeysIssue | ZodInvalidUnionIssue | ZodInvalidUnionDiscriminatorIssue | ZodInvalidEnumValueIssue | ZodInvalidArgumentsIssue | ZodInvalidReturnTypeIssue | ZodInvalidDateIssue | ZodInvalidStringIssue | ZodTooSmallIssue | ZodTooBigIssue | ZodInvalidIntersectionTypesIssue | ZodNotMultipleOfIssue | ZodNotFiniteIssue | ZodCustomIssue;
type ZodIssue = ZodIssueOptionalMessage & {
	fatal?: boolean;
	message: string;
};
declare const quotelessJson: (obj: any) => string;
type recursiveZodFormattedError<T> = T extends [
	any,
	...any[]
] ? {
	[K in keyof T]?: ZodFormattedError<T[K]>;
} : T extends any[] ? {
	[k: number]: ZodFormattedError<T[number]>;
} : T extends object ? {
	[K in keyof T]?: ZodFormattedError<T[K]>;
} : unknown;
type ZodFormattedError<T, U = string> = {
	_errors: U[];
} & recursiveZodFormattedError<NonNullable<T>>;
type inferFormattedError<T extends ZodType<any, any, any>, U = string> = ZodFormattedError<TypeOf<T>, U>;
declare class ZodError<T = any> extends Error {
	issues: ZodIssue[];
	get errors(): ZodIssue[];
	constructor(issues: ZodIssue[]);
	format(): ZodFormattedError<T>;
	format<U>(mapper: (issue: ZodIssue) => U): ZodFormattedError<T, U>;
	static create: (issues: ZodIssue[]) => ZodError<any>;
	static assert(value: unknown): asserts value is ZodError;
	toString(): string;
	get message(): string;
	get isEmpty(): boolean;
	addIssue: (sub: ZodIssue) => void;
	addIssues: (subs?: ZodIssue[]) => void;
	flatten(): typeToFlattenedError<T>;
	flatten<U>(mapper?: (issue: ZodIssue) => U): typeToFlattenedError<T, U>;
	get formErrors(): typeToFlattenedError<T, string>;
}
type stripPath<T extends object> = T extends any ? util.OmitKeys<T, "path"> : never;
type IssueData = stripPath<ZodIssueOptionalMessage> & {
	path?: (string | number)[];
	fatal?: boolean;
};
type ErrorMapCtx = {
	defaultError: string;
	data: any;
};
type ZodErrorMap = (issue: ZodIssueOptionalMessage, _ctx: ErrorMapCtx) => {
	message: string;
};
declare const errorMap: ZodErrorMap;
declare function setErrorMap(map: ZodErrorMap): void;
declare function getErrorMap(): ZodErrorMap;
declare const makeIssue: (params: {
	data: any;
	path: (string | number)[];
	errorMaps: ZodErrorMap[];
	issueData: IssueData;
}) => ZodIssue;
type ParseParams = {
	path: (string | number)[];
	errorMap: ZodErrorMap;
	async: boolean;
};
type ParsePathComponent = string | number;
type ParsePath = ParsePathComponent[];
declare const EMPTY_PATH: ParsePath;
interface ParseContext {
	readonly common: {
		readonly issues: ZodIssue[];
		readonly contextualErrorMap?: ZodErrorMap;
		readonly async: boolean;
	};
	readonly path: ParsePath;
	readonly schemaErrorMap?: ZodErrorMap;
	readonly parent: ParseContext | null;
	readonly data: any;
	readonly parsedType: ZodParsedType;
}
type ParseInput = {
	data: any;
	path: (string | number)[];
	parent: ParseContext;
};
declare function addIssueToContext(ctx: ParseContext, issueData: IssueData): void;
type ObjectPair = {
	key: SyncParseReturnType<any>;
	value: SyncParseReturnType<any>;
};
declare class ParseStatus {
	value: "aborted" | "dirty" | "valid";
	dirty(): void;
	abort(): void;
	static mergeArray(status: ParseStatus, results: SyncParseReturnType<any>[]): SyncParseReturnType;
	static mergeObjectAsync(status: ParseStatus, pairs: {
		key: ParseReturnType<any>;
		value: ParseReturnType<any>;
	}[]): Promise<SyncParseReturnType<any>>;
	static mergeObjectSync(status: ParseStatus, pairs: {
		key: SyncParseReturnType<any>;
		value: SyncParseReturnType<any>;
		alwaysSet?: boolean;
	}[]): SyncParseReturnType;
}
interface ParseResult {
	status: "aborted" | "dirty" | "valid";
	data: any;
}
type INVALID = {
	status: "aborted";
};
declare const INVALID: INVALID;
type DIRTY<T> = {
	status: "dirty";
	value: T;
};
declare const DIRTY: <T>(value: T) => DIRTY<T>;
type OK<T> = {
	status: "valid";
	value: T;
};
declare const OK: <T>(value: T) => OK<T>;
type SyncParseReturnType<T = any> = OK<T> | DIRTY<T> | INVALID;
type AsyncParseReturnType<T> = Promise<SyncParseReturnType<T>>;
type ParseReturnType<T> = SyncParseReturnType<T> | AsyncParseReturnType<T>;
declare const isAborted: (x: ParseReturnType<any>) => x is INVALID;
declare const isDirty: <T>(x: ParseReturnType<T>) => x is OK<T> | DIRTY<T>;
declare const isValid: <T>(x: ParseReturnType<T>) => x is OK<T>;
declare const isAsync: <T>(x: ParseReturnType<T>) => x is AsyncParseReturnType<T>;
declare namespace enumUtil {
	type UnionToIntersectionFn<T> = (T extends unknown ? (k: () => T) => void : never) extends (k: infer Intersection) => void ? Intersection : never;
	type GetUnionLast<T> = UnionToIntersectionFn<T> extends () => infer Last ? Last : never;
	type UnionToTuple<T, Tuple extends unknown[] = [
	]> = [
		T
	] extends [
		never
	] ? Tuple : UnionToTuple<Exclude<T, GetUnionLast<T>>, [
		GetUnionLast<T>,
		...Tuple
	]>;
	type CastToStringTuple<T> = T extends [
		string,
		...string[]
	] ? T : never;
	export type UnionToTupleString<T> = CastToStringTuple<UnionToTuple<T>>;
	export {};
}
declare namespace errorUtil {
	type ErrMessage = string | {
		message?: string;
	};
	const errToObj: (message?: ErrMessage) => {
		message?: string | undefined;
	};
	const toString: (message?: ErrMessage) => string | undefined;
}
declare namespace partialUtil {
	type DeepPartial<T extends ZodTypeAny> = T extends ZodObject<ZodRawShape> ? ZodObject<{
		[k in keyof T["shape"]]: ZodOptional<DeepPartial<T["shape"][k]>>;
	}, T["_def"]["unknownKeys"], T["_def"]["catchall"]> : T extends ZodArray<infer Type, infer Card> ? ZodArray<DeepPartial<Type>, Card> : T extends ZodOptional<infer Type> ? ZodOptional<DeepPartial<Type>> : T extends ZodNullable<infer Type> ? ZodNullable<DeepPartial<Type>> : T extends ZodTuple<infer Items> ? {
		[k in keyof Items]: Items[k] extends ZodTypeAny ? DeepPartial<Items[k]> : never;
	} extends infer PI ? PI extends ZodTupleItems ? ZodTuple<PI> : never : never : T;
}
type StandardSchemaV1<Input = unknown, Output = Input> = {
	/**
	 * The Standard Schema properties.
	 */
	readonly "~standard": StandardSchemaV1.Props<Input, Output>;
};
declare namespace StandardSchemaV1 {
	/**
	 * The Standard Schema properties interface.
	 */
	export interface Props<Input = unknown, Output = Input> {
		/**
		 * The version number of the standard.
		 */
		readonly version: 1;
		/**
		 * The vendor name of the schema library.
		 */
		readonly vendor: string;
		/**
		 * Validates unknown input values.
		 */
		readonly validate: (value: unknown) => Result<Output> | Promise<Result<Output>>;
		/**
		 * Inferred types associated with the schema.
		 */
		readonly types?: Types<Input, Output> | undefined;
	}
	/**
	 * The result interface of the validate function.
	 */
	export type Result<Output> = SuccessResult<Output> | FailureResult;
	/**
	 * The result interface if validation succeeds.
	 */
	export interface SuccessResult<Output> {
		/**
		 * The typed output value.
		 */
		readonly value: Output;
		/**
		 * The non-existent issues.
		 */
		readonly issues?: undefined;
	}
	/**
	 * The result interface if validation fails.
	 */
	export interface FailureResult {
		/**
		 * The issues of failed validation.
		 */
		readonly issues: ReadonlyArray<Issue>;
	}
	/**
	 * The issue interface of the failure output.
	 */
	export interface Issue {
		/**
		 * The error message of the issue.
		 */
		readonly message: string;
		/**
		 * The path of the issue, if any.
		 */
		readonly path?: ReadonlyArray<PropertyKey | PathSegment> | undefined;
	}
	/**
	 * The path segment interface of the issue.
	 */
	export interface PathSegment {
		/**
		 * The key representing a path segment.
		 */
		readonly key: PropertyKey;
	}
	/**
	 * The Standard Schema types interface.
	 */
	export interface Types<Input = unknown, Output = Input> {
		/**
		 * The input type of the schema.
		 */
		readonly input: Input;
		/**
		 * The output type of the schema.
		 */
		readonly output: Output;
	}
	/**
	 * Infers the input type of a Standard Schema.
	 */
	export type InferInput<Schema extends StandardSchemaV1> = NonNullable<Schema["~standard"]["types"]>["input"];
	/**
	 * Infers the output type of a Standard Schema.
	 */
	export type InferOutput<Schema extends StandardSchemaV1> = NonNullable<Schema["~standard"]["types"]>["output"];
	export {};
}
interface RefinementCtx {
	addIssue: (arg: IssueData) => void;
	path: (string | number)[];
}
type ZodRawShape = {
	[k: string]: ZodTypeAny;
};
type ZodTypeAny = ZodType<any, any, any>;
type TypeOf<T extends ZodType<any, any, any>> = T["_output"];
type input<T extends ZodType<any, any, any>> = T["_input"];
type output<T extends ZodType<any, any, any>> = T["_output"];
type CustomErrorParams = Partial<util.Omit<ZodCustomIssue, "code">>;
interface ZodTypeDef {
	errorMap?: ZodErrorMap;
	description?: string;
}
type RawCreateParams = {
	errorMap?: ZodErrorMap;
	invalid_type_error?: string;
	required_error?: string;
	message?: string;
	description?: string;
} | undefined;
type ProcessedCreateParams = {
	errorMap?: ZodErrorMap;
	description?: string;
};
type SafeParseSuccess<Output> = {
	success: true;
	data: Output;
	error?: never;
};
type SafeParseError<Input> = {
	success: false;
	error: ZodError<Input>;
	data?: never;
};
type SafeParseReturnType<Input, Output> = SafeParseSuccess<Output> | SafeParseError<Input>;
declare abstract class ZodType<Output = any, Def extends ZodTypeDef = ZodTypeDef, Input = Output> {
	readonly _type: Output;
	readonly _output: Output;
	readonly _input: Input;
	readonly _def: Def;
	get description(): string | undefined;
	"~standard": StandardSchemaV1.Props<Input, Output>;
	abstract _parse(input: ParseInput): ParseReturnType<Output>;
	_getType(input: ParseInput): string;
	_getOrReturnCtx(input: ParseInput, ctx?: ParseContext | undefined): ParseContext;
	_processInputParams(input: ParseInput): {
		status: ParseStatus;
		ctx: ParseContext;
	};
	_parseSync(input: ParseInput): SyncParseReturnType<Output>;
	_parseAsync(input: ParseInput): AsyncParseReturnType<Output>;
	parse(data: unknown, params?: Partial<ParseParams>): Output;
	safeParse(data: unknown, params?: Partial<ParseParams>): SafeParseReturnType<Input, Output>;
	"~validate"(data: unknown): StandardSchemaV1.Result<Output> | Promise<StandardSchemaV1.Result<Output>>;
	parseAsync(data: unknown, params?: Partial<ParseParams>): Promise<Output>;
	safeParseAsync(data: unknown, params?: Partial<ParseParams>): Promise<SafeParseReturnType<Input, Output>>;
	/** Alias of safeParseAsync */
	spa: (data: unknown, params?: Partial<ParseParams>) => Promise<SafeParseReturnType<Input, Output>>;
	refine<RefinedOutput extends Output>(check: (arg: Output) => arg is RefinedOutput, message?: string | CustomErrorParams | ((arg: Output) => CustomErrorParams)): ZodEffects<this, RefinedOutput, Input>;
	refine(check: (arg: Output) => unknown | Promise<unknown>, message?: string | CustomErrorParams | ((arg: Output) => CustomErrorParams)): ZodEffects<this, Output, Input>;
	refinement<RefinedOutput extends Output>(check: (arg: Output) => arg is RefinedOutput, refinementData: IssueData | ((arg: Output, ctx: RefinementCtx) => IssueData)): ZodEffects<this, RefinedOutput, Input>;
	refinement(check: (arg: Output) => boolean, refinementData: IssueData | ((arg: Output, ctx: RefinementCtx) => IssueData)): ZodEffects<this, Output, Input>;
	_refinement(refinement: RefinementEffect<Output>["refinement"]): ZodEffects<this, Output, Input>;
	superRefine<RefinedOutput extends Output>(refinement: (arg: Output, ctx: RefinementCtx) => arg is RefinedOutput): ZodEffects<this, RefinedOutput, Input>;
	superRefine(refinement: (arg: Output, ctx: RefinementCtx) => void): ZodEffects<this, Output, Input>;
	superRefine(refinement: (arg: Output, ctx: RefinementCtx) => Promise<void>): ZodEffects<this, Output, Input>;
	constructor(def: Def);
	optional(): ZodOptional<this>;
	nullable(): ZodNullable<this>;
	nullish(): ZodOptional<ZodNullable<this>>;
	array(): ZodArray<this>;
	promise(): ZodPromise<this>;
	or<T extends ZodTypeAny>(option: T): ZodUnion<[
		this,
		T
	]>;
	and<T extends ZodTypeAny>(incoming: T): ZodIntersection<this, T>;
	transform<NewOut>(transform: (arg: Output, ctx: RefinementCtx) => NewOut | Promise<NewOut>): ZodEffects<this, NewOut>;
	default(def: util.noUndefined<Input>): ZodDefault<this>;
	default(def: () => util.noUndefined<Input>): ZodDefault<this>;
	brand<B extends string | number | symbol>(brand?: B): ZodBranded<this, B>;
	catch(def: Output): ZodCatch<this>;
	catch(def: (ctx: {
		error: ZodError;
		input: Input;
	}) => Output): ZodCatch<this>;
	describe(description: string): this;
	pipe<T extends ZodTypeAny>(target: T): ZodPipeline<this, T>;
	readonly(): ZodReadonly<this>;
	isOptional(): boolean;
	isNullable(): boolean;
}
type IpVersion = "v4" | "v6";
type ZodStringCheck = {
	kind: "min";
	value: number;
	message?: string;
} | {
	kind: "max";
	value: number;
	message?: string;
} | {
	kind: "length";
	value: number;
	message?: string;
} | {
	kind: "email";
	message?: string;
} | {
	kind: "url";
	message?: string;
} | {
	kind: "emoji";
	message?: string;
} | {
	kind: "uuid";
	message?: string;
} | {
	kind: "nanoid";
	message?: string;
} | {
	kind: "cuid";
	message?: string;
} | {
	kind: "includes";
	value: string;
	position?: number;
	message?: string;
} | {
	kind: "cuid2";
	message?: string;
} | {
	kind: "ulid";
	message?: string;
} | {
	kind: "startsWith";
	value: string;
	message?: string;
} | {
	kind: "endsWith";
	value: string;
	message?: string;
} | {
	kind: "regex";
	regex: RegExp;
	message?: string;
} | {
	kind: "trim";
	message?: string;
} | {
	kind: "toLowerCase";
	message?: string;
} | {
	kind: "toUpperCase";
	message?: string;
} | {
	kind: "jwt";
	alg?: string;
	message?: string;
} | {
	kind: "datetime";
	offset: boolean;
	local: boolean;
	precision: number | null;
	message?: string;
} | {
	kind: "date";
	message?: string;
} | {
	kind: "time";
	precision: number | null;
	message?: string;
} | {
	kind: "duration";
	message?: string;
} | {
	kind: "ip";
	version?: IpVersion;
	message?: string;
} | {
	kind: "cidr";
	version?: IpVersion;
	message?: string;
} | {
	kind: "base64";
	message?: string;
} | {
	kind: "base64url";
	message?: string;
};
interface ZodStringDef extends ZodTypeDef {
	checks: ZodStringCheck[];
	typeName: ZodFirstPartyTypeKind.ZodString;
	coerce: boolean;
}
declare function datetimeRegex(args: {
	precision?: number | null;
	offset?: boolean;
	local?: boolean;
}): RegExp;
declare class ZodString extends ZodType<string, ZodStringDef, string> {
	_parse(input: ParseInput): ParseReturnType<string>;
	protected _regex(regex: RegExp, validation: StringValidation, message?: errorUtil.ErrMessage): ZodEffects<this, string, string>;
	_addCheck(check: ZodStringCheck): ZodString;
	email(message?: errorUtil.ErrMessage): ZodString;
	url(message?: errorUtil.ErrMessage): ZodString;
	emoji(message?: errorUtil.ErrMessage): ZodString;
	uuid(message?: errorUtil.ErrMessage): ZodString;
	nanoid(message?: errorUtil.ErrMessage): ZodString;
	cuid(message?: errorUtil.ErrMessage): ZodString;
	cuid2(message?: errorUtil.ErrMessage): ZodString;
	ulid(message?: errorUtil.ErrMessage): ZodString;
	base64(message?: errorUtil.ErrMessage): ZodString;
	base64url(message?: errorUtil.ErrMessage): ZodString;
	jwt(options?: {
		alg?: string;
		message?: string;
	}): ZodString;
	ip(options?: string | {
		version?: IpVersion;
		message?: string;
	}): ZodString;
	cidr(options?: string | {
		version?: IpVersion;
		message?: string;
	}): ZodString;
	datetime(options?: string | {
		message?: string | undefined;
		precision?: number | null;
		offset?: boolean;
		local?: boolean;
	}): ZodString;
	date(message?: string): ZodString;
	time(options?: string | {
		message?: string | undefined;
		precision?: number | null;
	}): ZodString;
	duration(message?: errorUtil.ErrMessage): ZodString;
	regex(regex: RegExp, message?: errorUtil.ErrMessage): ZodString;
	includes(value: string, options?: {
		message?: string;
		position?: number;
	}): ZodString;
	startsWith(value: string, message?: errorUtil.ErrMessage): ZodString;
	endsWith(value: string, message?: errorUtil.ErrMessage): ZodString;
	min(minLength: number, message?: errorUtil.ErrMessage): ZodString;
	max(maxLength: number, message?: errorUtil.ErrMessage): ZodString;
	length(len: number, message?: errorUtil.ErrMessage): ZodString;
	/**
	 * Equivalent to `.min(1)`
	 */
	nonempty(message?: errorUtil.ErrMessage): ZodString;
	trim(): ZodString;
	toLowerCase(): ZodString;
	toUpperCase(): ZodString;
	get isDatetime(): boolean;
	get isDate(): boolean;
	get isTime(): boolean;
	get isDuration(): boolean;
	get isEmail(): boolean;
	get isURL(): boolean;
	get isEmoji(): boolean;
	get isUUID(): boolean;
	get isNANOID(): boolean;
	get isCUID(): boolean;
	get isCUID2(): boolean;
	get isULID(): boolean;
	get isIP(): boolean;
	get isCIDR(): boolean;
	get isBase64(): boolean;
	get isBase64url(): boolean;
	get minLength(): number | null;
	get maxLength(): number | null;
	static create: (params?: RawCreateParams & {
		coerce?: true;
	}) => ZodString;
}
type ZodNumberCheck = {
	kind: "min";
	value: number;
	inclusive: boolean;
	message?: string;
} | {
	kind: "max";
	value: number;
	inclusive: boolean;
	message?: string;
} | {
	kind: "int";
	message?: string;
} | {
	kind: "multipleOf";
	value: number;
	message?: string;
} | {
	kind: "finite";
	message?: string;
};
interface ZodNumberDef extends ZodTypeDef {
	checks: ZodNumberCheck[];
	typeName: ZodFirstPartyTypeKind.ZodNumber;
	coerce: boolean;
}
declare class ZodNumber extends ZodType<number, ZodNumberDef, number> {
	_parse(input: ParseInput): ParseReturnType<number>;
	static create: (params?: RawCreateParams & {
		coerce?: boolean;
	}) => ZodNumber;
	gte(value: number, message?: errorUtil.ErrMessage): ZodNumber;
	min: (value: number, message?: errorUtil.ErrMessage) => ZodNumber;
	gt(value: number, message?: errorUtil.ErrMessage): ZodNumber;
	lte(value: number, message?: errorUtil.ErrMessage): ZodNumber;
	max: (value: number, message?: errorUtil.ErrMessage) => ZodNumber;
	lt(value: number, message?: errorUtil.ErrMessage): ZodNumber;
	protected setLimit(kind: "min" | "max", value: number, inclusive: boolean, message?: string): ZodNumber;
	_addCheck(check: ZodNumberCheck): ZodNumber;
	int(message?: errorUtil.ErrMessage): ZodNumber;
	positive(message?: errorUtil.ErrMessage): ZodNumber;
	negative(message?: errorUtil.ErrMessage): ZodNumber;
	nonpositive(message?: errorUtil.ErrMessage): ZodNumber;
	nonnegative(message?: errorUtil.ErrMessage): ZodNumber;
	multipleOf(value: number, message?: errorUtil.ErrMessage): ZodNumber;
	step: (value: number, message?: errorUtil.ErrMessage) => ZodNumber;
	finite(message?: errorUtil.ErrMessage): ZodNumber;
	safe(message?: errorUtil.ErrMessage): ZodNumber;
	get minValue(): number | null;
	get maxValue(): number | null;
	get isInt(): boolean;
	get isFinite(): boolean;
}
type ZodBigIntCheck = {
	kind: "min";
	value: bigint;
	inclusive: boolean;
	message?: string;
} | {
	kind: "max";
	value: bigint;
	inclusive: boolean;
	message?: string;
} | {
	kind: "multipleOf";
	value: bigint;
	message?: string;
};
interface ZodBigIntDef extends ZodTypeDef {
	checks: ZodBigIntCheck[];
	typeName: ZodFirstPartyTypeKind.ZodBigInt;
	coerce: boolean;
}
declare class ZodBigInt extends ZodType<bigint, ZodBigIntDef, bigint> {
	_parse(input: ParseInput): ParseReturnType<bigint>;
	_getInvalidInput(input: ParseInput): INVALID;
	static create: (params?: RawCreateParams & {
		coerce?: boolean;
	}) => ZodBigInt;
	gte(value: bigint, message?: errorUtil.ErrMessage): ZodBigInt;
	min: (value: bigint, message?: errorUtil.ErrMessage) => ZodBigInt;
	gt(value: bigint, message?: errorUtil.ErrMessage): ZodBigInt;
	lte(value: bigint, message?: errorUtil.ErrMessage): ZodBigInt;
	max: (value: bigint, message?: errorUtil.ErrMessage) => ZodBigInt;
	lt(value: bigint, message?: errorUtil.ErrMessage): ZodBigInt;
	protected setLimit(kind: "min" | "max", value: bigint, inclusive: boolean, message?: string): ZodBigInt;
	_addCheck(check: ZodBigIntCheck): ZodBigInt;
	positive(message?: errorUtil.ErrMessage): ZodBigInt;
	negative(message?: errorUtil.ErrMessage): ZodBigInt;
	nonpositive(message?: errorUtil.ErrMessage): ZodBigInt;
	nonnegative(message?: errorUtil.ErrMessage): ZodBigInt;
	multipleOf(value: bigint, message?: errorUtil.ErrMessage): ZodBigInt;
	get minValue(): bigint | null;
	get maxValue(): bigint | null;
}
interface ZodBooleanDef extends ZodTypeDef {
	typeName: ZodFirstPartyTypeKind.ZodBoolean;
	coerce: boolean;
}
declare class ZodBoolean extends ZodType<boolean, ZodBooleanDef, boolean> {
	_parse(input: ParseInput): ParseReturnType<boolean>;
	static create: (params?: RawCreateParams & {
		coerce?: boolean;
	}) => ZodBoolean;
}
type ZodDateCheck = {
	kind: "min";
	value: number;
	message?: string;
} | {
	kind: "max";
	value: number;
	message?: string;
};
interface ZodDateDef extends ZodTypeDef {
	checks: ZodDateCheck[];
	coerce: boolean;
	typeName: ZodFirstPartyTypeKind.ZodDate;
}
declare class ZodDate extends ZodType<Date, ZodDateDef, Date> {
	_parse(input: ParseInput): ParseReturnType<this["_output"]>;
	_addCheck(check: ZodDateCheck): ZodDate;
	min(minDate: Date, message?: errorUtil.ErrMessage): ZodDate;
	max(maxDate: Date, message?: errorUtil.ErrMessage): ZodDate;
	get minDate(): Date | null;
	get maxDate(): Date | null;
	static create: (params?: RawCreateParams & {
		coerce?: boolean;
	}) => ZodDate;
}
interface ZodSymbolDef extends ZodTypeDef {
	typeName: ZodFirstPartyTypeKind.ZodSymbol;
}
declare class ZodSymbol extends ZodType<symbol, ZodSymbolDef, symbol> {
	_parse(input: ParseInput): ParseReturnType<this["_output"]>;
	static create: (params?: RawCreateParams) => ZodSymbol;
}
interface ZodUndefinedDef extends ZodTypeDef {
	typeName: ZodFirstPartyTypeKind.ZodUndefined;
}
declare class ZodUndefined extends ZodType<undefined, ZodUndefinedDef, undefined> {
	_parse(input: ParseInput): ParseReturnType<this["_output"]>;
	params?: RawCreateParams;
	static create: (params?: RawCreateParams) => ZodUndefined;
}
interface ZodNullDef extends ZodTypeDef {
	typeName: ZodFirstPartyTypeKind.ZodNull;
}
declare class ZodNull extends ZodType<null, ZodNullDef, null> {
	_parse(input: ParseInput): ParseReturnType<this["_output"]>;
	static create: (params?: RawCreateParams) => ZodNull;
}
interface ZodAnyDef extends ZodTypeDef {
	typeName: ZodFirstPartyTypeKind.ZodAny;
}
declare class ZodAny extends ZodType<any, ZodAnyDef, any> {
	_any: true;
	_parse(input: ParseInput): ParseReturnType<this["_output"]>;
	static create: (params?: RawCreateParams) => ZodAny;
}
interface ZodUnknownDef extends ZodTypeDef {
	typeName: ZodFirstPartyTypeKind.ZodUnknown;
}
declare class ZodUnknown extends ZodType<unknown, ZodUnknownDef, unknown> {
	_unknown: true;
	_parse(input: ParseInput): ParseReturnType<this["_output"]>;
	static create: (params?: RawCreateParams) => ZodUnknown;
}
interface ZodNeverDef extends ZodTypeDef {
	typeName: ZodFirstPartyTypeKind.ZodNever;
}
declare class ZodNever extends ZodType<never, ZodNeverDef, never> {
	_parse(input: ParseInput): ParseReturnType<this["_output"]>;
	static create: (params?: RawCreateParams) => ZodNever;
}
interface ZodVoidDef extends ZodTypeDef {
	typeName: ZodFirstPartyTypeKind.ZodVoid;
}
declare class ZodVoid extends ZodType<void, ZodVoidDef, void> {
	_parse(input: ParseInput): ParseReturnType<this["_output"]>;
	static create: (params?: RawCreateParams) => ZodVoid;
}
interface ZodArrayDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
	type: T;
	typeName: ZodFirstPartyTypeKind.ZodArray;
	exactLength: {
		value: number;
		message?: string;
	} | null;
	minLength: {
		value: number;
		message?: string;
	} | null;
	maxLength: {
		value: number;
		message?: string;
	} | null;
}
type ArrayCardinality = "many" | "atleastone";
type arrayOutputType<T extends ZodTypeAny, Cardinality extends ArrayCardinality = "many"> = Cardinality extends "atleastone" ? [
	T["_output"],
	...T["_output"][]
] : T["_output"][];
declare class ZodArray<T extends ZodTypeAny, Cardinality extends ArrayCardinality = "many"> extends ZodType<arrayOutputType<T, Cardinality>, ZodArrayDef<T>, Cardinality extends "atleastone" ? [
	T["_input"],
	...T["_input"][]
] : T["_input"][]> {
	_parse(input: ParseInput): ParseReturnType<this["_output"]>;
	get element(): T;
	min(minLength: number, message?: errorUtil.ErrMessage): this;
	max(maxLength: number, message?: errorUtil.ErrMessage): this;
	length(len: number, message?: errorUtil.ErrMessage): this;
	nonempty(message?: errorUtil.ErrMessage): ZodArray<T, "atleastone">;
	static create: <T_1 extends ZodTypeAny>(schema: T_1, params?: RawCreateParams) => ZodArray<T_1, "many">;
}
type ZodNonEmptyArray<T extends ZodTypeAny> = ZodArray<T, "atleastone">;
type UnknownKeysParam = "passthrough" | "strict" | "strip";
interface ZodObjectDef<T extends ZodRawShape = ZodRawShape, UnknownKeys extends UnknownKeysParam = UnknownKeysParam, Catchall extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
	typeName: ZodFirstPartyTypeKind.ZodObject;
	shape: () => T;
	catchall: Catchall;
	unknownKeys: UnknownKeys;
}
type mergeTypes<A, B> = {
	[k in keyof A | keyof B]: k extends keyof B ? B[k] : k extends keyof A ? A[k] : never;
};
type objectOutputType<Shape extends ZodRawShape, Catchall extends ZodTypeAny, UnknownKeys extends UnknownKeysParam = UnknownKeysParam> = objectUtil.flatten<objectUtil.addQuestionMarks<baseObjectOutputType<Shape>>> & CatchallOutput<Catchall> & PassthroughType<UnknownKeys>;
type baseObjectOutputType<Shape extends ZodRawShape> = {
	[k in keyof Shape]: Shape[k]["_output"];
};
type objectInputType<Shape extends ZodRawShape, Catchall extends ZodTypeAny, UnknownKeys extends UnknownKeysParam = UnknownKeysParam> = objectUtil.flatten<baseObjectInputType<Shape>> & CatchallInput<Catchall> & PassthroughType<UnknownKeys>;
type baseObjectInputType<Shape extends ZodRawShape> = objectUtil.addQuestionMarks<{
	[k in keyof Shape]: Shape[k]["_input"];
}>;
type CatchallOutput<T extends ZodType> = ZodType extends T ? unknown : {
	[k: string]: T["_output"];
};
type CatchallInput<T extends ZodType> = ZodType extends T ? unknown : {
	[k: string]: T["_input"];
};
type PassthroughType<T extends UnknownKeysParam> = T extends "passthrough" ? {
	[k: string]: unknown;
} : unknown;
type deoptional<T extends ZodTypeAny> = T extends ZodOptional<infer U> ? deoptional<U> : T extends ZodNullable<infer U> ? ZodNullable<deoptional<U>> : T;
type SomeZodObject = ZodObject<ZodRawShape, UnknownKeysParam, ZodTypeAny>;
type noUnrecognized<Obj extends object, Shape extends object> = {
	[k in keyof Obj]: k extends keyof Shape ? Obj[k] : never;
};
declare class ZodObject<T extends ZodRawShape, UnknownKeys extends UnknownKeysParam = UnknownKeysParam, Catchall extends ZodTypeAny = ZodTypeAny, Output = objectOutputType<T, Catchall, UnknownKeys>, Input = objectInputType<T, Catchall, UnknownKeys>> extends ZodType<Output, ZodObjectDef<T, UnknownKeys, Catchall>, Input> {
	private _cached;
	_getCached(): {
		shape: T;
		keys: string[];
	};
	_parse(input: ParseInput): ParseReturnType<this["_output"]>;
	get shape(): T;
	strict(message?: errorUtil.ErrMessage): ZodObject<T, "strict", Catchall>;
	strip(): ZodObject<T, "strip", Catchall>;
	passthrough(): ZodObject<T, "passthrough", Catchall>;
	/**
	 * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.
	 * If you want to pass through unknown properties, use `.passthrough()` instead.
	 */
	nonstrict: () => ZodObject<T, "passthrough", Catchall>;
	extend<Augmentation extends ZodRawShape>(augmentation: Augmentation): ZodObject<objectUtil.extendShape<T, Augmentation>, UnknownKeys, Catchall>;
	/**
	 * @deprecated Use `.extend` instead
	 *  */
	augment: <Augmentation extends ZodRawShape>(augmentation: Augmentation) => ZodObject<objectUtil.extendShape<T, Augmentation>, UnknownKeys, Catchall>;
	/**
	 * Prior to zod@1.0.12 there was a bug in the
	 * inferred type of merged objects. Please
	 * upgrade if you are experiencing issues.
	 */
	merge<Incoming extends AnyZodObject, Augmentation extends Incoming["shape"]>(merging: Incoming): ZodObject<objectUtil.extendShape<T, Augmentation>, Incoming["_def"]["unknownKeys"], Incoming["_def"]["catchall"]>;
	setKey<Key extends string, Schema extends ZodTypeAny>(key: Key, schema: Schema): ZodObject<T & {
		[k in Key]: Schema;
	}, UnknownKeys, Catchall>;
	catchall<Index extends ZodTypeAny>(index: Index): ZodObject<T, UnknownKeys, Index>;
	pick<Mask extends util.Exactly<{
		[k in keyof T]?: true;
	}, Mask>>(mask: Mask): ZodObject<Pick<T, Extract<keyof T, keyof Mask>>, UnknownKeys, Catchall>;
	omit<Mask extends util.Exactly<{
		[k in keyof T]?: true;
	}, Mask>>(mask: Mask): ZodObject<Omit<T, keyof Mask>, UnknownKeys, Catchall>;
	/**
	 * @deprecated
	 */
	deepPartial(): partialUtil.DeepPartial<this>;
	partial(): ZodObject<{
		[k in keyof T]: ZodOptional<T[k]>;
	}, UnknownKeys, Catchall>;
	partial<Mask extends util.Exactly<{
		[k in keyof T]?: true;
	}, Mask>>(mask: Mask): ZodObject<objectUtil.noNever<{
		[k in keyof T]: k extends keyof Mask ? ZodOptional<T[k]> : T[k];
	}>, UnknownKeys, Catchall>;
	required(): ZodObject<{
		[k in keyof T]: deoptional<T[k]>;
	}, UnknownKeys, Catchall>;
	required<Mask extends util.Exactly<{
		[k in keyof T]?: true;
	}, Mask>>(mask: Mask): ZodObject<objectUtil.noNever<{
		[k in keyof T]: k extends keyof Mask ? deoptional<T[k]> : T[k];
	}>, UnknownKeys, Catchall>;
	keyof(): ZodEnum<enumUtil.UnionToTupleString<keyof T>>;
	static create: <T_1 extends ZodRawShape>(shape: T_1, params?: RawCreateParams) => ZodObject<T_1, "strip", ZodTypeAny, objectUtil.addQuestionMarks<baseObjectOutputType<T_1>, any> extends infer T_2 ? {
		[k in keyof T_2]: objectUtil.addQuestionMarks<baseObjectOutputType<T_1>, any>[k];
	} : never, baseObjectInputType<T_1> extends infer T_3 ? {
		[k_1 in keyof T_3]: baseObjectInputType<T_1>[k_1];
	} : never>;
	static strictCreate: <T_1 extends ZodRawShape>(shape: T_1, params?: RawCreateParams) => ZodObject<T_1, "strict", ZodTypeAny, objectUtil.addQuestionMarks<baseObjectOutputType<T_1>, any> extends infer T_2 ? {
		[k in keyof T_2]: objectUtil.addQuestionMarks<baseObjectOutputType<T_1>, any>[k];
	} : never, baseObjectInputType<T_1> extends infer T_3 ? {
		[k_1 in keyof T_3]: baseObjectInputType<T_1>[k_1];
	} : never>;
	static lazycreate: <T_1 extends ZodRawShape>(shape: () => T_1, params?: RawCreateParams) => ZodObject<T_1, "strip", ZodTypeAny, objectUtil.addQuestionMarks<baseObjectOutputType<T_1>, any> extends infer T_2 ? {
		[k in keyof T_2]: objectUtil.addQuestionMarks<baseObjectOutputType<T_1>, any>[k];
	} : never, baseObjectInputType<T_1> extends infer T_3 ? {
		[k_1 in keyof T_3]: baseObjectInputType<T_1>[k_1];
	} : never>;
}
type AnyZodObject = ZodObject<any, any, any>;
type ZodUnionOptions = Readonly<[
	ZodTypeAny,
	...ZodTypeAny[]
]>;
interface ZodUnionDef<T extends ZodUnionOptions = Readonly<[
	ZodTypeAny,
	ZodTypeAny,
	...ZodTypeAny[]
]>> extends ZodTypeDef {
	options: T;
	typeName: ZodFirstPartyTypeKind.ZodUnion;
}
declare class ZodUnion<T extends ZodUnionOptions> extends ZodType<T[number]["_output"], ZodUnionDef<T>, T[number]["_input"]> {
	_parse(input: ParseInput): ParseReturnType<this["_output"]>;
	get options(): T;
	static create: <T_1 extends readonly [
		ZodTypeAny,
		ZodTypeAny,
		...ZodTypeAny[]
	]>(types: T_1, params?: RawCreateParams) => ZodUnion<T_1>;
}
type ZodDiscriminatedUnionOption<Discriminator extends string> = ZodObject<{
	[key in Discriminator]: ZodTypeAny;
} & ZodRawShape, UnknownKeysParam, ZodTypeAny>;
interface ZodDiscriminatedUnionDef<Discriminator extends string, Options extends readonly ZodDiscriminatedUnionOption<string>[] = ZodDiscriminatedUnionOption<string>[]> extends ZodTypeDef {
	discriminator: Discriminator;
	options: Options;
	optionsMap: Map<Primitive, ZodDiscriminatedUnionOption<any>>;
	typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion;
}
declare class ZodDiscriminatedUnion<Discriminator extends string, Options extends readonly ZodDiscriminatedUnionOption<Discriminator>[]> extends ZodType<output<Options[number]>, ZodDiscriminatedUnionDef<Discriminator, Options>, input<Options[number]>> {
	_parse(input: ParseInput): ParseReturnType<this["_output"]>;
	get discriminator(): Discriminator;
	get options(): Options;
	get optionsMap(): Map<Primitive, ZodDiscriminatedUnionOption<any>>;
	/**
	 * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
	 * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
	 * have a different value for each object in the union.
	 * @param discriminator the name of the discriminator property
	 * @param types an array of object schemas
	 * @param params
	 */
	static create<Discriminator extends string, Types extends readonly [
		ZodDiscriminatedUnionOption<Discriminator>,
		...ZodDiscriminatedUnionOption<Discriminator>[]
	]>(discriminator: Discriminator, options: Types, params?: RawCreateParams): ZodDiscriminatedUnion<Discriminator, Types>;
}
interface ZodIntersectionDef<T extends ZodTypeAny = ZodTypeAny, U extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
	left: T;
	right: U;
	typeName: ZodFirstPartyTypeKind.ZodIntersection;
}
declare class ZodIntersection<T extends ZodTypeAny, U extends ZodTypeAny> extends ZodType<T["_output"] & U["_output"], ZodIntersectionDef<T, U>, T["_input"] & U["_input"]> {
	_parse(input: ParseInput): ParseReturnType<this["_output"]>;
	static create: <T_1 extends ZodTypeAny, U_1 extends ZodTypeAny>(left: T_1, right: U_1, params?: RawCreateParams) => ZodIntersection<T_1, U_1>;
}
type ZodTupleItems = [
	ZodTypeAny,
	...ZodTypeAny[]
];
type AssertArray<T> = T extends any[] ? T : never;
type OutputTypeOfTuple<T extends ZodTupleItems | [
]> = AssertArray<{
	[k in keyof T]: T[k] extends ZodType<any, any, any> ? T[k]["_output"] : never;
}>;
type OutputTypeOfTupleWithRest<T extends ZodTupleItems | [
], Rest extends ZodTypeAny | null = null> = Rest extends ZodTypeAny ? [
	...OutputTypeOfTuple<T>,
	...Rest["_output"][]
] : OutputTypeOfTuple<T>;
type InputTypeOfTuple<T extends ZodTupleItems | [
]> = AssertArray<{
	[k in keyof T]: T[k] extends ZodType<any, any, any> ? T[k]["_input"] : never;
}>;
type InputTypeOfTupleWithRest<T extends ZodTupleItems | [
], Rest extends ZodTypeAny | null = null> = Rest extends ZodTypeAny ? [
	...InputTypeOfTuple<T>,
	...Rest["_input"][]
] : InputTypeOfTuple<T>;
interface ZodTupleDef<T extends ZodTupleItems | [
] = ZodTupleItems, Rest extends ZodTypeAny | null = null> extends ZodTypeDef {
	items: T;
	rest: Rest;
	typeName: ZodFirstPartyTypeKind.ZodTuple;
}
type AnyZodTuple = ZodTuple<[
	ZodTypeAny,
	...ZodTypeAny[]
] | [
], ZodTypeAny | null>;
declare class ZodTuple<T extends [
	ZodTypeAny,
	...ZodTypeAny[]
] | [
] = [
	ZodTypeAny,
	...ZodTypeAny[]
], Rest extends ZodTypeAny | null = null> extends ZodType<OutputTypeOfTupleWithRest<T, Rest>, ZodTupleDef<T, Rest>, InputTypeOfTupleWithRest<T, Rest>> {
	_parse(input: ParseInput): ParseReturnType<this["_output"]>;
	get items(): T;
	rest<Rest extends ZodTypeAny>(rest: Rest): ZodTuple<T, Rest>;
	static create: <T_1 extends [
	] | [
		ZodTypeAny,
		...ZodTypeAny[]
	]>(schemas: T_1, params?: RawCreateParams) => ZodTuple<T_1, null>;
}
interface ZodRecordDef<Key extends KeySchema = ZodString, Value extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
	valueType: Value;
	keyType: Key;
	typeName: ZodFirstPartyTypeKind.ZodRecord;
}
type KeySchema = ZodType<string | number | symbol, any, any>;
type RecordType<K extends string | number | symbol, V> = [
	string
] extends [
	K
] ? Record<K, V> : [
	number
] extends [
	K
] ? Record<K, V> : [
	symbol
] extends [
	K
] ? Record<K, V> : [
	BRAND<string | number | symbol>
] extends [
	K
] ? Record<K, V> : Partial<Record<K, V>>;
declare class ZodRecord<Key extends KeySchema = ZodString, Value extends ZodTypeAny = ZodTypeAny> extends ZodType<RecordType<Key["_output"], Value["_output"]>, ZodRecordDef<Key, Value>, RecordType<Key["_input"], Value["_input"]>> {
	get keySchema(): Key;
	get valueSchema(): Value;
	_parse(input: ParseInput): ParseReturnType<this["_output"]>;
	get element(): Value;
	static create<Value extends ZodTypeAny>(valueType: Value, params?: RawCreateParams): ZodRecord<ZodString, Value>;
	static create<Keys extends KeySchema, Value extends ZodTypeAny>(keySchema: Keys, valueType: Value, params?: RawCreateParams): ZodRecord<Keys, Value>;
}
interface ZodMapDef<Key extends ZodTypeAny = ZodTypeAny, Value extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
	valueType: Value;
	keyType: Key;
	typeName: ZodFirstPartyTypeKind.ZodMap;
}
declare class ZodMap<Key extends ZodTypeAny = ZodTypeAny, Value extends ZodTypeAny = ZodTypeAny> extends ZodType<Map<Key["_output"], Value["_output"]>, ZodMapDef<Key, Value>, Map<Key["_input"], Value["_input"]>> {
	get keySchema(): Key;
	get valueSchema(): Value;
	_parse(input: ParseInput): ParseReturnType<this["_output"]>;
	static create: <Key_1 extends ZodTypeAny = ZodTypeAny, Value_1 extends ZodTypeAny = ZodTypeAny>(keyType: Key_1, valueType: Value_1, params?: RawCreateParams) => ZodMap<Key_1, Value_1>;
}
interface ZodSetDef<Value extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
	valueType: Value;
	typeName: ZodFirstPartyTypeKind.ZodSet;
	minSize: {
		value: number;
		message?: string;
	} | null;
	maxSize: {
		value: number;
		message?: string;
	} | null;
}
declare class ZodSet<Value extends ZodTypeAny = ZodTypeAny> extends ZodType<Set<Value["_output"]>, ZodSetDef<Value>, Set<Value["_input"]>> {
	_parse(input: ParseInput): ParseReturnType<this["_output"]>;
	min(minSize: number, message?: errorUtil.ErrMessage): this;
	max(maxSize: number, message?: errorUtil.ErrMessage): this;
	size(size: number, message?: errorUtil.ErrMessage): this;
	nonempty(message?: errorUtil.ErrMessage): ZodSet<Value>;
	static create: <Value_1 extends ZodTypeAny = ZodTypeAny>(valueType: Value_1, params?: RawCreateParams) => ZodSet<Value_1>;
}
interface ZodFunctionDef<Args extends ZodTuple<any, any> = ZodTuple<any, any>, Returns extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
	args: Args;
	returns: Returns;
	typeName: ZodFirstPartyTypeKind.ZodFunction;
}
type OuterTypeOfFunction<Args extends ZodTuple<any, any>, Returns extends ZodTypeAny> = Args["_input"] extends Array<any> ? (...args: Args["_input"]) => Returns["_output"] : never;
type InnerTypeOfFunction<Args extends ZodTuple<any, any>, Returns extends ZodTypeAny> = Args["_output"] extends Array<any> ? (...args: Args["_output"]) => Returns["_input"] : never;
declare class ZodFunction<Args extends ZodTuple<any, any>, Returns extends ZodTypeAny> extends ZodType<OuterTypeOfFunction<Args, Returns>, ZodFunctionDef<Args, Returns>, InnerTypeOfFunction<Args, Returns>> {
	_parse(input: ParseInput): ParseReturnType<any>;
	parameters(): Args;
	returnType(): Returns;
	args<Items extends Parameters<(typeof ZodTuple)["create"]>[0]>(...items: Items): ZodFunction<ZodTuple<Items, ZodUnknown>, Returns>;
	returns<NewReturnType extends ZodType<any, any, any>>(returnType: NewReturnType): ZodFunction<Args, NewReturnType>;
	implement<F extends InnerTypeOfFunction<Args, Returns>>(func: F): ReturnType<F> extends Returns["_output"] ? (...args: Args["_input"]) => ReturnType<F> : OuterTypeOfFunction<Args, Returns>;
	strictImplement(func: InnerTypeOfFunction<Args, Returns>): InnerTypeOfFunction<Args, Returns>;
	validate: <F extends InnerTypeOfFunction<Args, Returns>>(func: F) => ReturnType<F> extends Returns["_output"] ? (...args: Args["_input"]) => ReturnType<F> : OuterTypeOfFunction<Args, Returns>;
	static create(): ZodFunction<ZodTuple<[
	], ZodUnknown>, ZodUnknown>;
	static create<T extends AnyZodTuple = ZodTuple<[
	], ZodUnknown>>(args: T): ZodFunction<T, ZodUnknown>;
	static create<T extends AnyZodTuple, U extends ZodTypeAny>(args: T, returns: U): ZodFunction<T, U>;
	static create<T extends AnyZodTuple = ZodTuple<[
	], ZodUnknown>, U extends ZodTypeAny = ZodUnknown>(args: T, returns: U, params?: RawCreateParams): ZodFunction<T, U>;
}
interface ZodLazyDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
	getter: () => T;
	typeName: ZodFirstPartyTypeKind.ZodLazy;
}
declare class ZodLazy<T extends ZodTypeAny> extends ZodType<output<T>, ZodLazyDef<T>, input<T>> {
	get schema(): T;
	_parse(input: ParseInput): ParseReturnType<this["_output"]>;
	static create: <T_1 extends ZodTypeAny>(getter: () => T_1, params?: RawCreateParams) => ZodLazy<T_1>;
}
interface ZodLiteralDef<T = any> extends ZodTypeDef {
	value: T;
	typeName: ZodFirstPartyTypeKind.ZodLiteral;
}
declare class ZodLiteral<T> extends ZodType<T, ZodLiteralDef<T>, T> {
	_parse(input: ParseInput): ParseReturnType<this["_output"]>;
	get value(): T;
	static create: <T_1 extends Primitive>(value: T_1, params?: RawCreateParams) => ZodLiteral<T_1>;
}
type ArrayKeys = keyof any[];
type Indices<T> = Exclude<keyof T, ArrayKeys>;
type EnumValues<T extends string = string> = readonly [
	T,
	...T[]
];
type Values<T extends EnumValues> = {
	[k in T[number]]: k;
};
interface ZodEnumDef<T extends EnumValues = EnumValues> extends ZodTypeDef {
	values: T;
	typeName: ZodFirstPartyTypeKind.ZodEnum;
}
type Writeable<T> = {
	-readonly [P in keyof T]: T[P];
};
type FilterEnum<Values, ToExclude> = Values extends [
] ? [
] : Values extends [
	infer Head,
	...infer Rest
] ? Head extends ToExclude ? FilterEnum<Rest, ToExclude> : [
	Head,
	...FilterEnum<Rest, ToExclude>
] : never;
type typecast<A, T> = A extends T ? A : never;
declare function createZodEnum<U extends string, T extends Readonly<[
	U,
	...U[]
]>>(values: T, params?: RawCreateParams): ZodEnum<Writeable<T>>;
declare function createZodEnum<U extends string, T extends [
	U,
	...U[]
]>(values: T, params?: RawCreateParams): ZodEnum<T>;
declare class ZodEnum<T extends [
	string,
	...string[]
]> extends ZodType<T[number], ZodEnumDef<T>, T[number]> {
	#private;
	_parse(input: ParseInput): ParseReturnType<this["_output"]>;
	get options(): T;
	get enum(): Values<T>;
	get Values(): Values<T>;
	get Enum(): Values<T>;
	extract<ToExtract extends readonly [
		T[number],
		...T[number][]
	]>(values: ToExtract, newDef?: RawCreateParams): ZodEnum<Writeable<ToExtract>>;
	exclude<ToExclude extends readonly [
		T[number],
		...T[number][]
	]>(values: ToExclude, newDef?: RawCreateParams): ZodEnum<typecast<Writeable<FilterEnum<T, ToExclude[number]>>, [
		string,
		...string[]
	]>>;
	static create: typeof createZodEnum;
}
interface ZodNativeEnumDef<T extends EnumLike = EnumLike> extends ZodTypeDef {
	values: T;
	typeName: ZodFirstPartyTypeKind.ZodNativeEnum;
}
type EnumLike = {
	[k: string]: string | number;
	[nu: number]: string;
};
declare class ZodNativeEnum<T extends EnumLike> extends ZodType<T[keyof T], ZodNativeEnumDef<T>, T[keyof T]> {
	#private;
	_parse(input: ParseInput): ParseReturnType<T[keyof T]>;
	get enum(): T;
	static create: <T_1 extends EnumLike>(values: T_1, params?: RawCreateParams) => ZodNativeEnum<T_1>;
}
interface ZodPromiseDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
	type: T;
	typeName: ZodFirstPartyTypeKind.ZodPromise;
}
declare class ZodPromise<T extends ZodTypeAny> extends ZodType<Promise<T["_output"]>, ZodPromiseDef<T>, Promise<T["_input"]>> {
	unwrap(): T;
	_parse(input: ParseInput): ParseReturnType<this["_output"]>;
	static create: <T_1 extends ZodTypeAny>(schema: T_1, params?: RawCreateParams) => ZodPromise<T_1>;
}
type Refinement<T> = (arg: T, ctx: RefinementCtx) => any;
type SuperRefinement<T> = (arg: T, ctx: RefinementCtx) => void | Promise<void>;
type RefinementEffect<T> = {
	type: "refinement";
	refinement: (arg: T, ctx: RefinementCtx) => any;
};
type TransformEffect<T> = {
	type: "transform";
	transform: (arg: T, ctx: RefinementCtx) => any;
};
type PreprocessEffect<T> = {
	type: "preprocess";
	transform: (arg: T, ctx: RefinementCtx) => any;
};
type Effect<T> = RefinementEffect<T> | TransformEffect<T> | PreprocessEffect<T>;
interface ZodEffectsDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
	schema: T;
	typeName: ZodFirstPartyTypeKind.ZodEffects;
	effect: Effect<any>;
}
declare class ZodEffects<T extends ZodTypeAny, Output = output<T>, Input = input<T>> extends ZodType<Output, ZodEffectsDef<T>, Input> {
	innerType(): T;
	sourceType(): T;
	_parse(input: ParseInput): ParseReturnType<this["_output"]>;
	static create: <I extends ZodTypeAny>(schema: I, effect: Effect<I["_output"]>, params?: RawCreateParams) => ZodEffects<I, I["_output"]>;
	static createWithPreprocess: <I extends ZodTypeAny>(preprocess: (arg: unknown, ctx: RefinementCtx) => unknown, schema: I, params?: RawCreateParams) => ZodEffects<I, I["_output"], unknown>;
}
interface ZodOptionalDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
	innerType: T;
	typeName: ZodFirstPartyTypeKind.ZodOptional;
}
type ZodOptionalType<T extends ZodTypeAny> = ZodOptional<T>;
declare class ZodOptional<T extends ZodTypeAny> extends ZodType<T["_output"] | undefined, ZodOptionalDef<T>, T["_input"] | undefined> {
	_parse(input: ParseInput): ParseReturnType<this["_output"]>;
	unwrap(): T;
	static create: <T_1 extends ZodTypeAny>(type: T_1, params?: RawCreateParams) => ZodOptional<T_1>;
}
interface ZodNullableDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
	innerType: T;
	typeName: ZodFirstPartyTypeKind.ZodNullable;
}
type ZodNullableType<T extends ZodTypeAny> = ZodNullable<T>;
declare class ZodNullable<T extends ZodTypeAny> extends ZodType<T["_output"] | null, ZodNullableDef<T>, T["_input"] | null> {
	_parse(input: ParseInput): ParseReturnType<this["_output"]>;
	unwrap(): T;
	static create: <T_1 extends ZodTypeAny>(type: T_1, params?: RawCreateParams) => ZodNullable<T_1>;
}
interface ZodDefaultDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
	innerType: T;
	defaultValue: () => util.noUndefined<T["_input"]>;
	typeName: ZodFirstPartyTypeKind.ZodDefault;
}
declare class ZodDefault<T extends ZodTypeAny> extends ZodType<util.noUndefined<T["_output"]>, ZodDefaultDef<T>, T["_input"] | undefined> {
	_parse(input: ParseInput): ParseReturnType<this["_output"]>;
	removeDefault(): T;
	static create: <T_1 extends ZodTypeAny>(type: T_1, params: {
		errorMap?: ZodErrorMap | undefined;
		invalid_type_error?: string | undefined;
		required_error?: string | undefined;
		message?: string | undefined;
		description?: string | undefined;
	} & {
		default: T_1["_input"] | (() => util.noUndefined<T_1["_input"]>);
	}) => ZodDefault<T_1>;
}
interface ZodCatchDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
	innerType: T;
	catchValue: (ctx: {
		error: ZodError;
		input: unknown;
	}) => T["_input"];
	typeName: ZodFirstPartyTypeKind.ZodCatch;
}
declare class ZodCatch<T extends ZodTypeAny> extends ZodType<T["_output"], ZodCatchDef<T>, unknown> {
	_parse(input: ParseInput): ParseReturnType<this["_output"]>;
	removeCatch(): T;
	static create: <T_1 extends ZodTypeAny>(type: T_1, params: {
		errorMap?: ZodErrorMap | undefined;
		invalid_type_error?: string | undefined;
		required_error?: string | undefined;
		message?: string | undefined;
		description?: string | undefined;
	} & {
		catch: T_1["_output"] | (() => T_1["_output"]);
	}) => ZodCatch<T_1>;
}
interface ZodNaNDef extends ZodTypeDef {
	typeName: ZodFirstPartyTypeKind.ZodNaN;
}
declare class ZodNaN extends ZodType<number, ZodNaNDef, number> {
	_parse(input: ParseInput): ParseReturnType<any>;
	static create: (params?: RawCreateParams) => ZodNaN;
}
interface ZodBrandedDef<T extends ZodTypeAny> extends ZodTypeDef {
	type: T;
	typeName: ZodFirstPartyTypeKind.ZodBranded;
}
declare const BRAND: unique symbol;
type BRAND<T extends string | number | symbol> = {
	[BRAND]: {
		[k in T]: true;
	};
};
declare class ZodBranded<T extends ZodTypeAny, B extends string | number | symbol> extends ZodType<T["_output"] & BRAND<B>, ZodBrandedDef<T>, T["_input"]> {
	_parse(input: ParseInput): ParseReturnType<any>;
	unwrap(): T;
}
interface ZodPipelineDef<A extends ZodTypeAny, B extends ZodTypeAny> extends ZodTypeDef {
	in: A;
	out: B;
	typeName: ZodFirstPartyTypeKind.ZodPipeline;
}
declare class ZodPipeline<A extends ZodTypeAny, B extends ZodTypeAny> extends ZodType<B["_output"], ZodPipelineDef<A, B>, A["_input"]> {
	_parse(input: ParseInput): ParseReturnType<any>;
	static create<A extends ZodTypeAny, B extends ZodTypeAny>(a: A, b: B): ZodPipeline<A, B>;
}
type BuiltIn = (((...args: any[]) => any) | (new (...args: any[]) => any)) | {
	readonly [Symbol.toStringTag]: string;
} | Date | Error | Generator | Promise<unknown> | RegExp;
type MakeReadonly<T> = T extends Map<infer K, infer V> ? ReadonlyMap<K, V> : T extends Set<infer V> ? ReadonlySet<V> : T extends [
	infer Head,
	...infer Tail
] ? readonly [
	Head,
	...Tail
] : T extends Array<infer V> ? ReadonlyArray<V> : T extends BuiltIn ? T : Readonly<T>;
interface ZodReadonlyDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
	innerType: T;
	typeName: ZodFirstPartyTypeKind.ZodReadonly;
}
declare class ZodReadonly<T extends ZodTypeAny> extends ZodType<MakeReadonly<T["_output"]>, ZodReadonlyDef<T>, MakeReadonly<T["_input"]>> {
	_parse(input: ParseInput): ParseReturnType<this["_output"]>;
	static create: <T_1 extends ZodTypeAny>(type: T_1, params?: RawCreateParams) => ZodReadonly<T_1>;
	unwrap(): T;
}
type CustomParams = CustomErrorParams & {
	fatal?: boolean;
};
declare function custom<T>(check?: (data: any) => any, _params?: string | CustomParams | ((input: any) => CustomParams), 
/**
 * @deprecated
 *
 * Pass `fatal` into the params object instead:
 *
 * ```ts
 * z.string().custom((val) => val.length > 5, { fatal: false })
 * ```
 *
 */
fatal?: boolean): ZodType<T, ZodTypeDef, T>;
declare const late: {
	object: <T extends ZodRawShape>(shape: () => T, params?: RawCreateParams) => ZodObject<T, "strip">;
};
declare enum ZodFirstPartyTypeKind {
	ZodString = "ZodString",
	ZodNumber = "ZodNumber",
	ZodNaN = "ZodNaN",
	ZodBigInt = "ZodBigInt",
	ZodBoolean = "ZodBoolean",
	ZodDate = "ZodDate",
	ZodSymbol = "ZodSymbol",
	ZodUndefined = "ZodUndefined",
	ZodNull = "ZodNull",
	ZodAny = "ZodAny",
	ZodUnknown = "ZodUnknown",
	ZodNever = "ZodNever",
	ZodVoid = "ZodVoid",
	ZodArray = "ZodArray",
	ZodObject = "ZodObject",
	ZodUnion = "ZodUnion",
	ZodDiscriminatedUnion = "ZodDiscriminatedUnion",
	ZodIntersection = "ZodIntersection",
	ZodTuple = "ZodTuple",
	ZodRecord = "ZodRecord",
	ZodMap = "ZodMap",
	ZodSet = "ZodSet",
	ZodFunction = "ZodFunction",
	ZodLazy = "ZodLazy",
	ZodLiteral = "ZodLiteral",
	ZodEnum = "ZodEnum",
	ZodEffects = "ZodEffects",
	ZodNativeEnum = "ZodNativeEnum",
	ZodOptional = "ZodOptional",
	ZodNullable = "ZodNullable",
	ZodDefault = "ZodDefault",
	ZodCatch = "ZodCatch",
	ZodPromise = "ZodPromise",
	ZodBranded = "ZodBranded",
	ZodPipeline = "ZodPipeline",
	ZodReadonly = "ZodReadonly"
}
type ZodFirstPartySchemaTypes = ZodString | ZodNumber | ZodNaN | ZodBigInt | ZodBoolean | ZodDate | ZodUndefined | ZodNull | ZodAny | ZodUnknown | ZodNever | ZodVoid | ZodArray<any, any> | ZodObject<any, any, any> | ZodUnion<any> | ZodDiscriminatedUnion<any, any> | ZodIntersection<any, any> | ZodTuple<any, any> | ZodRecord<any, any> | ZodMap<any> | ZodSet<any> | ZodFunction<any, any> | ZodLazy<any> | ZodLiteral<any> | ZodEnum<any> | ZodEffects<any, any, any> | ZodNativeEnum<any> | ZodOptional<any> | ZodNullable<any> | ZodDefault<any> | ZodCatch<any> | ZodPromise<any> | ZodBranded<any, any> | ZodPipeline<any, any> | ZodReadonly<any> | ZodSymbol;
declare abstract class Class {
	constructor(..._: any[]);
}
declare const instanceOfType: <T extends typeof Class>(cls: T, params?: CustomParams) => ZodType<InstanceType<T>, ZodTypeDef, InstanceType<T>>;
declare const stringType: (params?: RawCreateParams & {
	coerce?: true;
}) => ZodString;
declare const numberType: (params?: RawCreateParams & {
	coerce?: boolean;
}) => ZodNumber;
declare const nanType: (params?: RawCreateParams) => ZodNaN;
declare const bigIntType: (params?: RawCreateParams & {
	coerce?: boolean;
}) => ZodBigInt;
declare const booleanType: (params?: RawCreateParams & {
	coerce?: boolean;
}) => ZodBoolean;
declare const dateType: (params?: RawCreateParams & {
	coerce?: boolean;
}) => ZodDate;
declare const symbolType: (params?: RawCreateParams) => ZodSymbol;
declare const undefinedType: (params?: RawCreateParams) => ZodUndefined;
declare const nullType: (params?: RawCreateParams) => ZodNull;
declare const anyType: (params?: RawCreateParams) => ZodAny;
declare const unknownType: (params?: RawCreateParams) => ZodUnknown;
declare const neverType: (params?: RawCreateParams) => ZodNever;
declare const voidType: (params?: RawCreateParams) => ZodVoid;
declare const arrayType: <T extends ZodTypeAny>(schema: T, params?: RawCreateParams) => ZodArray<T>;
declare const objectType: <T extends ZodRawShape>(shape: T, params?: RawCreateParams) => ZodObject<T, "strip", ZodTypeAny, objectOutputType<T, ZodTypeAny, "strip">, objectInputType<T, ZodTypeAny, "strip">>;
declare const strictObjectType: <T extends ZodRawShape>(shape: T, params?: RawCreateParams) => ZodObject<T, "strict">;
declare const unionType: <T extends readonly [
	ZodTypeAny,
	ZodTypeAny,
	...ZodTypeAny[]
]>(types: T, params?: RawCreateParams) => ZodUnion<T>;
declare const discriminatedUnionType: typeof ZodDiscriminatedUnion.create;
declare const intersectionType: <T extends ZodTypeAny, U extends ZodTypeAny>(left: T, right: U, params?: RawCreateParams) => ZodIntersection<T, U>;
declare const tupleType: <T extends [
] | [
	ZodTypeAny,
	...ZodTypeAny[]
]>(schemas: T, params?: RawCreateParams) => ZodTuple<T, null>;
declare const recordType: typeof ZodRecord.create;
declare const mapType: <Key extends ZodTypeAny = ZodTypeAny, Value extends ZodTypeAny = ZodTypeAny>(keyType: Key, valueType: Value, params?: RawCreateParams) => ZodMap<Key, Value>;
declare const setType: <Value extends ZodTypeAny = ZodTypeAny>(valueType: Value, params?: RawCreateParams) => ZodSet<Value>;
declare const functionType: typeof ZodFunction.create;
declare const lazyType: <T extends ZodTypeAny>(getter: () => T, params?: RawCreateParams) => ZodLazy<T>;
declare const literalType: <T extends Primitive>(value: T, params?: RawCreateParams) => ZodLiteral<T>;
declare const enumType: typeof createZodEnum;
declare const nativeEnumType: <T extends EnumLike>(values: T, params?: RawCreateParams) => ZodNativeEnum<T>;
declare const promiseType: <T extends ZodTypeAny>(schema: T, params?: RawCreateParams) => ZodPromise<T>;
declare const effectsType: <I extends ZodTypeAny>(schema: I, effect: Effect<I["_output"]>, params?: RawCreateParams) => ZodEffects<I, I["_output"]>;
declare const optionalType: <T extends ZodTypeAny>(type: T, params?: RawCreateParams) => ZodOptional<T>;
declare const nullableType: <T extends ZodTypeAny>(type: T, params?: RawCreateParams) => ZodNullable<T>;
declare const preprocessType: <I extends ZodTypeAny>(preprocess: (arg: unknown, ctx: RefinementCtx) => unknown, schema: I, params?: RawCreateParams) => ZodEffects<I, I["_output"], unknown>;
declare const pipelineType: typeof ZodPipeline.create;
declare const ostring: () => ZodOptional<ZodString>;
declare const onumber: () => ZodOptional<ZodNumber>;
declare const oboolean: () => ZodOptional<ZodBoolean>;
declare const coerce: {
	string: (params?: RawCreateParams & {
		coerce?: true;
	}) => ZodString;
	number: (params?: RawCreateParams & {
		coerce?: boolean;
	}) => ZodNumber;
	boolean: (params?: RawCreateParams & {
		coerce?: boolean;
	}) => ZodBoolean;
	bigint: (params?: RawCreateParams & {
		coerce?: boolean;
	}) => ZodBigInt;
	date: (params?: RawCreateParams & {
		coerce?: boolean;
	}) => ZodDate;
};
declare const NEVER: never;
interface SerializedFields {
	[key: string]: any;
}
interface BaseSerialized<T extends string> {
	lc: number;
	type: T;
	id: string[];
	name?: string;
	graph?: Record<string, any>;
}
interface SerializedConstructor extends BaseSerialized<"constructor"> {
	kwargs: SerializedFields;
}
interface SerializedSecret extends BaseSerialized<"secret"> {
}
interface SerializedNotImplemented extends BaseSerialized<"not_implemented"> {
}
type Serialized = SerializedConstructor | SerializedSecret | SerializedNotImplemented;
interface SerializableInterface {
	get lc_id(): string[];
}
declare abstract class Serializable implements SerializableInterface {
	lc_serializable: boolean;
	lc_kwargs: SerializedFields;
	/**
	 * A path to the module that contains the class, eg. ["langchain", "llms"]
	 * Usually should be the same as the entrypoint the class is exported from.
	 */
	abstract lc_namespace: string[];
	/**
	 * The name of the serializable. Override to provide an alias or
	 * to preserve the serialized module name in minified environments.
	 *
	 * Implemented as a static method to support loading logic.
	 */
	static lc_name(): string;
	/**
	 * The final serialized identifier for the module.
	 */
	get lc_id(): string[];
	/**
	 * A map of secrets, which will be omitted from serialization.
	 * Keys are paths to the secret in constructor args, e.g. "foo.bar.baz".
	 * Values are the secret ids, which will be used when deserializing.
	 */
	get lc_secrets(): {
		[key: string]: string;
	} | undefined;
	/**
	 * A map of additional attributes to merge with constructor args.
	 * Keys are the attribute names, e.g. "foo".
	 * Values are the attribute values, which will be serialized.
	 * These attributes need to be accepted by the constructor as arguments.
	 */
	get lc_attributes(): SerializedFields | undefined;
	/**
	 * A map of aliases for constructor args.
	 * Keys are the attribute names, e.g. "foo".
	 * Values are the alias that will replace the key in serialization.
	 * This is used to eg. make argument names match Python.
	 */
	get lc_aliases(): {
		[key: string]: string;
	} | undefined;
	/**
	 * A manual list of keys that should be serialized.
	 * If not overridden, all fields passed into the constructor will be serialized.
	 */
	get lc_serializable_keys(): string[] | undefined;
	constructor(kwargs?: SerializedFields, ..._args: never[]);
	toJSON(): Serialized;
	toJSONNotImplemented(): SerializedNotImplemented;
}
type StringWithAutocomplete<T> = T | (string & Record<never, never>);
type ChainValues = Record<string, any>;
interface StoredMessageData {
	content: string;
	role: string | undefined;
	name: string | undefined;
	tool_call_id: string | undefined;
	additional_kwargs?: Record<string, any>;
	/** Response metadata. For example: response headers, logprobs, token counts. */
	response_metadata?: Record<string, any>;
	id?: string;
}
interface StoredMessage {
	type: string;
	data: StoredMessageData;
}
type MessageType = "human" | "ai" | "generic" | "developer" | "system" | "function" | "tool" | "remove";
type ImageDetail = "auto" | "low" | "high";
type MessageContentText = {
	type: "text";
	text: string;
};
type MessageContentImageUrl = {
	type: "image_url";
	image_url: string | {
		url: string;
		detail?: ImageDetail;
	};
};
type MessageContentComplex = MessageContentText | MessageContentImageUrl | (Record<string, any> & {
	type?: "text" | "image_url" | string;
}) | (Record<string, any> & {
	type?: never;
});
type MessageContent = string | MessageContentComplex[];
interface FunctionCall {
	/**
	 * The arguments to call the function with, as generated by the model in JSON
	 * format. Note that the model does not always generate valid JSON, and may
	 * hallucinate parameters not defined by your function schema. Validate the
	 * arguments in your code before calling your function.
	 */
	arguments: string;
	/**
	 * The name of the function to call.
	 */
	name: string;
}
type BaseMessageFields = {
	content: MessageContent;
	name?: string;
	additional_kwargs?: {
		/**
		 * @deprecated Use "tool_calls" field on AIMessages instead
		 */
		function_call?: FunctionCall;
		/**
		 * @deprecated Use "tool_calls" field on AIMessages instead
		 */
		tool_calls?: OpenAIToolCall[];
		[key: string]: unknown;
	};
	/** Response metadata. For example: response headers, logprobs, token counts. */
	response_metadata?: Record<string, any>;
	/**
	 * An optional unique identifier for the message. This should ideally be
	 * provided by the provider/model which created the message.
	 */
	id?: string;
};
declare abstract class BaseMessage extends Serializable implements BaseMessageFields {
	lc_namespace: string[];
	lc_serializable: boolean;
	get lc_aliases(): Record<string, string>;
	/**
	 * Get text content of the message.
	 */
	get text(): string;
	/** The content of the message. */
	content: MessageContent;
	/** The name of the message sender in a multi-user chat. */
	name?: string;
	/** Additional keyword arguments */
	additional_kwargs: NonNullable<BaseMessageFields["additional_kwargs"]>;
	/** Response metadata. For example: response headers, logprobs, token counts. */
	response_metadata: NonNullable<BaseMessageFields["response_metadata"]>;
	/**
	 * An optional unique identifier for the message. This should ideally be
	 * provided by the provider/model which created the message.
	 */
	id?: string;
	/**
	 * @deprecated Use .getType() instead or import the proper typeguard.
	 * For example:
	 *
	 * ```ts
	 * import { isAIMessage } from "@langchain/core/messages";
	 *
	 * const message = new AIMessage("Hello!");
	 * isAIMessage(message); // true
	 * ```
	 */
	abstract _getType(): MessageType;
	/** The type of the message. */
	getType(): MessageType;
	constructor(fields: string | BaseMessageFields, 
	/** @deprecated */
	kwargs?: Record<string, unknown>);
	toDict(): StoredMessage;
	static lc_name(): string;
	get _printableFields(): Record<string, unknown>;
	_updateId(value: string | undefined): void;
	get [Symbol.toStringTag](): any;
}
type OpenAIToolCall = {
	/**
	 * The ID of the tool call.
	 */
	id: string;
	/**
	 * The function that the model called.
	 */
	function: FunctionCall;
	/**
	 * The type of the tool. Currently, only `function` is supported.
	 */
	type: "function";
	index?: number;
};
declare abstract class BaseMessageChunk extends BaseMessage {
	abstract concat(chunk: BaseMessageChunk): BaseMessageChunk;
}
type MessageFieldWithRole = {
	role: StringWithAutocomplete<"user" | "assistant" | MessageType>;
	content: MessageContent;
	name?: string;
} & Record<string, unknown>;
type BaseMessageLike = BaseMessage | MessageFieldWithRole | [
	StringWithAutocomplete<MessageType | "user" | "assistant" | "placeholder">,
	MessageContent
] | string
/**
 * @deprecated Specifying "type" is deprecated and will be removed in 0.4.0.
 */
 | ({
	type: MessageType | "user" | "assistant" | "placeholder";
} & BaseMessageFields & Record<string, unknown>) | SerializedConstructor;
declare const RUN_KEY = "__run";
interface Generation {
	/**
	 * Generated text output
	 */
	text: string;
	/**
	 * Raw generation info response from the provider.
	 * May include things like reason for finishing (e.g. in {@link OpenAI})
	 */
	generationInfo?: Record<string, any>;
}
type GenerationChunkFields = {
	text: string;
	generationInfo?: Record<string, any>;
};
declare class GenerationChunk implements Generation {
	text: string;
	generationInfo?: Record<string, any>;
	constructor(fields: GenerationChunkFields);
	concat(chunk: GenerationChunk): GenerationChunk;
}
type LLMResult = {
	/**
	 * List of the things generated. Each input could have multiple {@link Generation | generations}, hence this is a list of lists.
	 */
	generations: Generation[][];
	/**
	 * Dictionary of arbitrary LLM-provider specific output.
	 */
	llmOutput?: Record<string, any>;
	/**
	 * Dictionary of run metadata
	 */
	[RUN_KEY]?: Record<string, any>;
};
interface ChatGeneration extends Generation {
	message: BaseMessage;
}
type ChatGenerationChunkFields = GenerationChunkFields & {
	message: BaseMessageChunk;
};
declare class ChatGenerationChunk extends GenerationChunk implements ChatGeneration {
	message: BaseMessageChunk;
	constructor(fields: ChatGenerationChunkFields);
	concat(chunk: ChatGenerationChunk): ChatGenerationChunk;
}
type ToolCall = {
	name: string;
	args: Record<string, any>;
	id?: string;
	type?: "tool_call";
};
declare abstract class BaseCache<T = Generation[]> {
	abstract lookup(prompt: string, llmKey: string): Promise<T | null>;
	abstract update(prompt: string, llmKey: string, value: T): Promise<void>;
}
interface BasePromptValueInterface extends Serializable {
	toString(): string;
	toChatMessages(): BaseMessage[];
}
type AgentAction = {
	tool: string;
	toolInput: string | Record<string, any>;
	log: string;
};
type AgentFinish = {
	returnValues: Record<string, any>;
	log: string;
};
interface DocumentInput<Metadata extends Record<string, any> = Record<string, any>> {
	pageContent: string;
	metadata?: Metadata;
	/**
	 * An optional identifier for the document.
	 *
	 * Ideally this should be unique across the document collection and formatted
	 * as a UUID, but this will not be enforced.
	 */
	id?: string;
}
interface DocumentInterface<Metadata extends Record<string, any> = Record<string, any>> {
	pageContent: string;
	metadata: Metadata;
	/**
	 * An optional identifier for the document.
	 *
	 * Ideally this should be unique across the document collection and formatted
	 * as a UUID, but this will not be enforced.
	 */
	id?: string;
}
declare class Document$1<Metadata extends Record<string, any> = Record<string, any>> implements DocumentInput, DocumentInterface {
	pageContent: string;
	metadata: Metadata;
	/**
	 * An optional identifier for the document.
	 *
	 * Ideally this should be unique across the document collection and formatted
	 * as a UUID, but this will not be enforced.
	 */
	id?: string;
	constructor(fields: DocumentInput<Metadata>);
}
type Error$1 = any;
interface BaseCallbackHandlerInput {
	ignoreLLM?: boolean;
	ignoreChain?: boolean;
	ignoreAgent?: boolean;
	ignoreRetriever?: boolean;
	ignoreCustomEvent?: boolean;
	_awaitHandler?: boolean;
	raiseError?: boolean;
}
interface NewTokenIndices {
	prompt: number;
	completion: number;
}
type HandleLLMNewTokenCallbackFields = {
	chunk?: GenerationChunk | ChatGenerationChunk;
};
declare abstract class BaseCallbackHandlerMethodsClass {
	/**
	 * Called at the start of an LLM or Chat Model run, with the prompt(s)
	 * and the run ID.
	 */
	handleLLMStart?(llm: Serialized, prompts: string[], runId: string, parentRunId?: string, extraParams?: Record<string, unknown>, tags?: string[], metadata?: Record<string, unknown>, runName?: string): // eslint-disable-next-line @typescript-eslint/no-explicit-any
	Promise<any> | any;
	/**
	 * Called when an LLM/ChatModel in `streaming` mode produces a new token
	 */
	handleLLMNewToken?(token: string, 
	/**
	 * idx.prompt is the index of the prompt that produced the token
	 *   (if there are multiple prompts)
	 * idx.completion is the index of the completion that produced the token
	 *   (if multiple completions per prompt are requested)
	 */
	idx: NewTokenIndices, runId: string, parentRunId?: string, tags?: string[], fields?: HandleLLMNewTokenCallbackFields): // eslint-disable-next-line @typescript-eslint/no-explicit-any
	Promise<any> | any;
	/**
	 * Called if an LLM/ChatModel run encounters an error
	 */
	handleLLMError?(err: Error$1, runId: string, parentRunId?: string, tags?: string[], extraParams?: Record<string, unknown>): // eslint-disable-next-line @typescript-eslint/no-explicit-any
	Promise<any> | any;
	/**
	 * Called at the end of an LLM/ChatModel run, with the output and the run ID.
	 */
	handleLLMEnd?(output: LLMResult, runId: string, parentRunId?: string, tags?: string[], extraParams?: Record<string, unknown>): // eslint-disable-next-line @typescript-eslint/no-explicit-any
	Promise<any> | any;
	/**
	 * Called at the start of a Chat Model run, with the prompt(s)
	 * and the run ID.
	 */
	handleChatModelStart?(llm: Serialized, messages: BaseMessage[][], runId: string, parentRunId?: string, extraParams?: Record<string, unknown>, tags?: string[], metadata?: Record<string, unknown>, runName?: string): // eslint-disable-next-line @typescript-eslint/no-explicit-any
	Promise<any> | any;
	/**
	 * Called at the start of a Chain run, with the chain name and inputs
	 * and the run ID.
	 */
	handleChainStart?(chain: Serialized, inputs: ChainValues, runId: string, parentRunId?: string, tags?: string[], metadata?: Record<string, unknown>, runType?: string, runName?: string): // eslint-disable-next-line @typescript-eslint/no-explicit-any
	Promise<any> | any;
	/**
	 * Called if a Chain run encounters an error
	 */
	handleChainError?(err: Error$1, runId: string, parentRunId?: string, tags?: string[], kwargs?: {
		inputs?: Record<string, unknown>;
	}): // eslint-disable-next-line @typescript-eslint/no-explicit-any
	Promise<any> | any;
	/**
	 * Called at the end of a Chain run, with the outputs and the run ID.
	 */
	handleChainEnd?(outputs: ChainValues, runId: string, parentRunId?: string, tags?: string[], kwargs?: {
		inputs?: Record<string, unknown>;
	}): // eslint-disable-next-line @typescript-eslint/no-explicit-any
	Promise<any> | any;
	/**
	 * Called at the start of a Tool run, with the tool name and input
	 * and the run ID.
	 */
	handleToolStart?(tool: Serialized, input: string, runId: string, parentRunId?: string, tags?: string[], metadata?: Record<string, unknown>, runName?: string): // eslint-disable-next-line @typescript-eslint/no-explicit-any
	Promise<any> | any;
	/**
	 * Called if a Tool run encounters an error
	 */
	handleToolError?(err: Error$1, runId: string, parentRunId?: string, tags?: string[]): // eslint-disable-next-line @typescript-eslint/no-explicit-any
	Promise<any> | any;
	/**
	 * Called at the end of a Tool run, with the tool output and the run ID.
	 */
	handleToolEnd?(output: any, runId: string, parentRunId?: string, tags?: string[]): // eslint-disable-next-line @typescript-eslint/no-explicit-any
	Promise<any> | any;
	handleText?(text: string, runId: string, parentRunId?: string, tags?: string[]): Promise<void> | void;
	/**
	 * Called when an agent is about to execute an action,
	 * with the action and the run ID.
	 */
	handleAgentAction?(action: AgentAction, runId: string, parentRunId?: string, tags?: string[]): Promise<void> | void;
	/**
	 * Called when an agent finishes execution, before it exits.
	 * with the final output and the run ID.
	 */
	handleAgentEnd?(action: AgentFinish, runId: string, parentRunId?: string, tags?: string[]): Promise<void> | void;
	handleRetrieverStart?(retriever: Serialized, query: string, runId: string, parentRunId?: string, tags?: string[], metadata?: Record<string, unknown>, name?: string): // eslint-disable-next-line @typescript-eslint/no-explicit-any
	Promise<any> | any;
	handleRetrieverEnd?(documents: DocumentInterface[], runId: string, parentRunId?: string, tags?: string[]): // eslint-disable-next-line @typescript-eslint/no-explicit-any
	Promise<any> | any;
	handleRetrieverError?(err: Error$1, runId: string, parentRunId?: string, tags?: string[]): // eslint-disable-next-line @typescript-eslint/no-explicit-any
	Promise<any> | any;
	handleCustomEvent?(eventName: string, data: any, runId: string, tags?: string[], metadata?: Record<string, any>): // eslint-disable-next-line @typescript-eslint/no-explicit-any
	Promise<any> | any;
}
type CallbackHandlerMethods = BaseCallbackHandlerMethodsClass;
interface CallbackHandlerPrefersStreaming {
	readonly lc_prefer_streaming: boolean;
}
declare abstract class BaseCallbackHandler extends BaseCallbackHandlerMethodsClass implements BaseCallbackHandlerInput, Serializable {
	lc_serializable: boolean;
	get lc_namespace(): [
		"langchain_core",
		"callbacks",
		string
	];
	get lc_secrets(): {
		[key: string]: string;
	} | undefined;
	get lc_attributes(): {
		[key: string]: string;
	} | undefined;
	get lc_aliases(): {
		[key: string]: string;
	} | undefined;
	get lc_serializable_keys(): string[] | undefined;
	/**
	 * The name of the serializable. Override to provide an alias or
	 * to preserve the serialized module name in minified environments.
	 *
	 * Implemented as a static method to support loading logic.
	 */
	static lc_name(): string;
	/**
	 * The final serialized identifier for the module.
	 */
	get lc_id(): string[];
	lc_kwargs: SerializedFields;
	abstract name: string;
	ignoreLLM: boolean;
	ignoreChain: boolean;
	ignoreAgent: boolean;
	ignoreRetriever: boolean;
	ignoreCustomEvent: boolean;
	raiseError: boolean;
	awaitHandlers: boolean;
	constructor(input?: BaseCallbackHandlerInput);
	copy(): BaseCallbackHandler;
	toJSON(): Serialized;
	toJSONNotImplemented(): SerializedNotImplemented;
	static fromMethods(methods: CallbackHandlerMethods): {
		name: string;
		lc_serializable: boolean;
		readonly lc_namespace: [
			"langchain_core",
			"callbacks",
			string
		];
		readonly lc_secrets: {
			[key: string]: string;
		} | undefined;
		readonly lc_attributes: {
			[key: string]: string;
		} | undefined;
		readonly lc_aliases: {
			[key: string]: string;
		} | undefined;
		readonly lc_serializable_keys: string[] | undefined;
		/**
		 * The final serialized identifier for the module.
		 */
		readonly lc_id: string[];
		lc_kwargs: SerializedFields;
		ignoreLLM: boolean;
		ignoreChain: boolean;
		ignoreAgent: boolean;
		ignoreRetriever: boolean;
		ignoreCustomEvent: boolean;
		raiseError: boolean;
		awaitHandlers: boolean;
		copy(): BaseCallbackHandler;
		toJSON(): Serialized;
		toJSONNotImplemented(): SerializedNotImplemented;
		/**
		 * Called at the start of an LLM or Chat Model run, with the prompt(s)
		 * and the run ID.
		 */
		handleLLMStart?(llm: Serialized, prompts: string[], runId: string, parentRunId?: string | undefined, extraParams?: Record<string, unknown> | undefined, tags?: string[] | undefined, metadata?: Record<string, unknown> | undefined, runName?: string | undefined): any;
		/**
		 * Called when an LLM/ChatModel in `streaming` mode produces a new token
		 */
		handleLLMNewToken?(token: string, idx: NewTokenIndices, runId: string, parentRunId?: string | undefined, tags?: string[] | undefined, fields?: HandleLLMNewTokenCallbackFields | undefined): any;
		/**
		 * Called if an LLM/ChatModel run encounters an error
		 */
		handleLLMError?(err: any, runId: string, parentRunId?: string | undefined, tags?: string[] | undefined, extraParams?: Record<string, unknown> | undefined): any;
		/**
		 * Called at the end of an LLM/ChatModel run, with the output and the run ID.
		 */
		handleLLMEnd?(output: LLMResult, runId: string, parentRunId?: string | undefined, tags?: string[] | undefined, extraParams?: Record<string, unknown> | undefined): any;
		/**
		 * Called at the start of a Chat Model run, with the prompt(s)
		 * and the run ID.
		 */
		handleChatModelStart?(llm: Serialized, messages: BaseMessage[][], runId: string, parentRunId?: string | undefined, extraParams?: Record<string, unknown> | undefined, tags?: string[] | undefined, metadata?: Record<string, unknown> | undefined, runName?: string | undefined): any;
		/**
		 * Called at the start of a Chain run, with the chain name and inputs
		 * and the run ID.
		 */
		handleChainStart?(chain: Serialized, inputs: ChainValues, runId: string, parentRunId?: string | undefined, tags?: string[] | undefined, metadata?: Record<string, unknown> | undefined, runType?: string | undefined, runName?: string | undefined): any;
		/**
		 * Called if a Chain run encounters an error
		 */
		handleChainError?(err: any, runId: string, parentRunId?: string | undefined, tags?: string[] | undefined, kwargs?: {
			inputs?: Record<string, unknown> | undefined;
		} | undefined): any;
		/**
		 * Called at the end of a Chain run, with the outputs and the run ID.
		 */
		handleChainEnd?(outputs: ChainValues, runId: string, parentRunId?: string | undefined, tags?: string[] | undefined, kwargs?: {
			inputs?: Record<string, unknown> | undefined;
		} | undefined): any;
		/**
		 * Called at the start of a Tool run, with the tool name and input
		 * and the run ID.
		 */
		handleToolStart?(tool: Serialized, input: string, runId: string, parentRunId?: string | undefined, tags?: string[] | undefined, metadata?: Record<string, unknown> | undefined, runName?: string | undefined): any;
		/**
		 * Called if a Tool run encounters an error
		 */
		handleToolError?(err: any, runId: string, parentRunId?: string | undefined, tags?: string[] | undefined): any;
		/**
		 * Called at the end of a Tool run, with the tool output and the run ID.
		 */
		handleToolEnd?(output: any, runId: string, parentRunId?: string | undefined, tags?: string[] | undefined): any;
		handleText?(text: string, runId: string, parentRunId?: string | undefined, tags?: string[] | undefined): void | Promise<void>;
		/**
		 * Called when an agent is about to execute an action,
		 * with the action and the run ID.
		 */
		handleAgentAction?(action: AgentAction, runId: string, parentRunId?: string | undefined, tags?: string[] | undefined): void | Promise<void>;
		/**
		 * Called when an agent finishes execution, before it exits.
		 * with the final output and the run ID.
		 */
		handleAgentEnd?(action: AgentFinish, runId: string, parentRunId?: string | undefined, tags?: string[] | undefined): void | Promise<void>;
		handleRetrieverStart?(retriever: Serialized, query: string, runId: string, parentRunId?: string | undefined, tags?: string[] | undefined, metadata?: Record<string, unknown> | undefined, name?: string | undefined): any;
		handleRetrieverEnd?(documents: DocumentInterface<Record<string, any>>[], runId: string, parentRunId?: string | undefined, tags?: string[] | undefined): any;
		handleRetrieverError?(err: any, runId: string, parentRunId?: string | undefined, tags?: string[] | undefined): any;
		handleCustomEvent?(eventName: string, data: any, runId: string, tags?: string[] | undefined, metadata?: Record<string, any> | undefined): any;
	};
}
type ResponseCallback = (response?: Response) => Promise<boolean>;
interface AsyncCallerParams {
	/**
	 * The maximum number of concurrent calls that can be made.
	 * Defaults to `Infinity`, which means no limit.
	 */
	maxConcurrency?: number;
	/**
	 * The maximum number of retries that can be made for a single call,
	 * with an exponential backoff between each attempt. Defaults to 6.
	 */
	maxRetries?: number;
	onFailedResponseHook?: ResponseCallback;
	debug?: boolean;
}
interface TracerSession {
	tenant_id: string;
	id: string;
	start_time: number;
	end_time?: number;
	description?: string;
	name?: string;
	/** Extra metadata for the project. */
	extra?: KVMap;
	reference_dataset_id?: string;
}
interface TracerSessionResult extends TracerSession {
	run_count?: number;
	latency_p50?: number;
	latency_p99?: number;
	total_tokens?: number;
	prompt_tokens?: number;
	completion_tokens?: number;
	last_run_start_time?: number;
	feedback_stats?: Record<string, unknown>;
	run_facets?: KVMap[];
}
type KVMap = Record<string, any>;
type ScoreType = number | boolean | null;
type ValueType = number | boolean | string | object | null;
type DataType = "kv" | "llm" | "chat";
interface BaseExample {
	dataset_id: string;
	inputs: KVMap;
	outputs?: KVMap;
	metadata?: KVMap;
	source_run_id?: string;
}
interface AttachmentInfo {
	presigned_url: string;
	mime_type?: string;
}
type AttachmentData = Uint8Array | ArrayBuffer;
type AttachmentDescription = {
	mimeType: string;
	data: AttachmentData;
};
type Attachments = Record<string, [
	string,
	AttachmentData
] | AttachmentDescription>;
interface BaseRun {
	/** Optionally, a unique identifier for the run. */
	id?: string;
	/** A human-readable name for the run. */
	name: string;
	/** The epoch time at which the run started, if available. */
	start_time?: number;
	/** Specifies the type of run (tool, chain, llm, etc.). */
	run_type: string;
	/** The epoch time at which the run ended, if applicable. */
	end_time?: number;
	/** Any additional metadata or settings for the run. */
	extra?: KVMap;
	/** Error message, captured if the run faces any issues. */
	error?: string;
	/** Serialized state of the run for potential future use. */
	serialized?: object;
	/** Events like 'start', 'end' linked to the run. */
	events?: KVMap[];
	/** Inputs that were used to initiate the run. */
	inputs: KVMap;
	/** Outputs produced by the run, if any. */
	outputs?: KVMap;
	/** ID of an example that might be related to this run. */
	reference_example_id?: string;
	/** ID of a parent run, if this run is part of a larger operation. */
	parent_run_id?: string;
	/** Tags for further categorizing or annotating the run. */
	tags?: string[];
	/** Unique ID assigned to every run within this nested trace. **/
	trace_id?: string;
	/**
	 * The dotted order for the run.
	 *
	 * This is a string composed of {time}{run-uuid}.* so that a trace can be
	 * sorted in the order it was executed.
	 *
	 * Example:
	 * - Parent: 20230914T223155647Z1b64098b-4ab7-43f6-afee-992304f198d8
	 * - Children:
	 *    - 20230914T223155647Z1b64098b-4ab7-43f6-afee-992304f198d8.20230914T223155649Z809ed3a2-0172-4f4d-8a02-a64e9b7a0f8a
	 *   - 20230915T223155647Z1b64098b-4ab7-43f6-afee-992304f198d8.20230914T223155650Zc8d9f4c5-6c5a-4b2d-9b1c-3d9d7a7c5c7c
	 */
	dotted_order?: string;
	/**
	 * Attachments associated with the run.
	 * Each entry is a tuple of [mime_type, bytes]
	 */
	attachments?: Attachments;
}
type S3URL = {
	ROOT: {
		/** A pre-signed URL */
		presigned_url: string;
		/** The S3 path to the object in storage */
		s3_url: string;
	};
};
interface Run extends BaseRun {
	/** A unique identifier for the run, mandatory when loaded from DB. */
	id: string;
	/** The ID of the project that owns this run. */
	session_id?: string;
	/** IDs of any child runs spawned by this run. */
	child_run_ids?: string[];
	/** Child runs, loaded explicitly via a heavier query. */
	child_runs?: Run[];
	/** Stats capturing feedback for this run. */
	feedback_stats?: KVMap;
	/** The URL path where this run is accessible within the app. */
	app_path?: string;
	/** The manifest ID that correlates with this run. */
	manifest_id?: string;
	/** The current status of the run, such as 'success'. */
	status?: string;
	/** Number of tokens used in the prompt. */
	prompt_tokens?: number;
	/** Number of tokens generated in the completion. */
	completion_tokens?: number;
	/** Total token count, combining prompt and completion. */
	total_tokens?: number;
	/** Time when the first token was processed. */
	first_token_time?: number;
	/** IDs of parent runs, if multiple exist. */
	parent_run_ids?: string[];
	/** Whether the run is included in a dataset. */
	in_dataset?: boolean;
	/** The output S3 URLs */
	outputs_s3_urls?: S3URL;
	/** The input S3 URLs */
	inputs_s3_urls?: S3URL;
}
interface RunCreate extends BaseRun {
	revision_id?: string;
	child_runs?: this[];
	session_name?: string;
}
interface RunUpdate {
	id?: string;
	end_time?: number;
	extra?: KVMap;
	tags?: string[];
	error?: string;
	inputs?: KVMap;
	outputs?: KVMap;
	parent_run_id?: string;
	reference_example_id?: string;
	events?: KVMap[];
	session_id?: string;
	session_name?: string;
	/** Unique ID assigned to every run within this nested trace. **/
	trace_id?: string;
	/**
	 * The dotted order for the run.
	 *
	 * This is a string composed of {time}{run-uuid}.* so that a trace can be
	 * sorted in the order it was executed.
	 *
	 * Example:
	 * - Parent: 20230914T223155647Z1b64098b-4ab7-43f6-afee-992304f198d8
	 * - Children:
	 *    - 20230914T223155647Z1b64098b-4ab7-43f6-afee-992304f198d8.20230914T223155649Z809ed3a2-0172-4f4d-8a02-a64e9b7a0f8a
	 *   - 20230915T223155647Z1b64098b-4ab7-43f6-afee-992304f198d8.20230914T223155650Zc8d9f4c5-6c5a-4b2d-9b1c-3d9d7a7c5c7c
	 */
	dotted_order?: string;
	/**
	 * Attachments associated with the run.
	 * Each entry is a tuple of [mime_type, bytes]
	 */
	attachments?: Attachments;
}
interface ExampleCreate {
	id?: string;
	inputs: KVMap;
	outputs?: KVMap;
	metadata?: KVMap;
	split?: string | string[];
	attachments?: Attachments;
	created_at?: string;
	dataset_id?: string;
	dataset_name?: string;
	source_run_id?: string;
	use_source_run_io?: boolean;
	use_source_run_attachments?: string[];
}
interface ExampleUpdate {
	id: string;
	inputs?: KVMap;
	outputs?: KVMap;
	metadata?: KVMap;
	split?: string | string[];
	attachments?: Attachments;
	attachments_operations?: KVMap;
	dataset_id?: string;
}
interface ExampleUpdateWithoutId extends Omit<ExampleUpdate, "id"> {
}
interface UploadExamplesResponse {
	count: number;
	example_ids: string[];
}
interface UpdateExamplesResponse extends UploadExamplesResponse {
}
interface Example extends BaseExample {
	id: string;
	created_at: string;
	modified_at?: string;
	source_run_id?: string;
	runs: Run[];
	attachments?: Record<string, AttachmentInfo>;
	split?: string | string[];
}
interface ExampleSearch extends BaseExample {
	id: string;
}
interface BaseDataset {
	name: string;
	description: string;
	tenant_id: string;
	data_type?: DataType;
	inputs_schema_definition?: KVMap;
	outputs_schema_definition?: KVMap;
}
interface Dataset extends BaseDataset {
	id: string;
	created_at: string;
	modified_at: string;
	example_count?: number;
	session_count?: number;
	last_session_start_time?: number;
}
interface DatasetShareSchema {
	dataset_id: string;
	share_token: string;
	url: string;
}
interface DatasetVersion {
	tags?: string[];
	as_of: string;
}
interface FeedbackSourceBase {
	type: string;
	metadata?: KVMap;
}
interface APIFeedbackSource extends FeedbackSourceBase {
	type: "api";
}
interface ModelFeedbackSource extends FeedbackSourceBase {
	type: "model";
}
interface FeedbackBase {
	created_at: string;
	modified_at: string;
	run_id: string;
	key: string;
	score: ScoreType;
	value: ValueType;
	comment: string | null;
	correction: string | object | null;
	feedback_source: APIFeedbackSource | ModelFeedbackSource | KVMap | null;
}
interface Feedback extends FeedbackBase {
	id: string;
}
interface LangChainBaseMessage {
	_getType: () => string;
	content: string;
	additional_kwargs?: KVMap;
}
interface FeedbackIngestToken {
	id: string;
	url: string;
	expires_at: string;
}
interface TimeDelta {
	days?: number;
	hours?: number;
	minutes?: number;
}
interface FeedbackCategory {
	value: number;
	label?: string | null;
}
interface FeedbackConfig {
	/**
	 * The type of feedback.
	 * - "continuous": Feedback with a continuous numeric.
	 * - "categorical": Feedback with a categorical value (classes)
	 * - "freeform": Feedback with a freeform text value (notes).
	 */
	type: "continuous" | "categorical" | "freeform";
	/**
	 * The minimum value for continuous feedback.
	 */
	min?: number | null;
	/**
	 * The maximum value for continuous feedback.
	 */
	max?: number | null;
	/**
	 * The categories for categorical feedback.
	 * Each category can be a string or an object with additional properties.
	 *
	 * If feedback is categorical, this defines the valid categories the server will accept.
	 * Not applicable to continuous or freeform feedback types.
	 */
	categories?: FeedbackCategory[] | null;
}
interface DatasetDiffInfo {
	examples_modified: string[];
	examples_added: string[];
	examples_removed: string[];
}
interface ComparativeExperiment {
	id: string;
	name: string;
	description: string;
	tenant_id: string;
	created_at: string;
	modified_at: string;
	reference_dataset_id: string;
	extra?: Record<string, unknown>;
	experiments_info?: Array<Record<string, unknown>>;
	feedback_stats?: Record<string, unknown>;
}
interface PromptCommit {
	owner: string;
	repo: string;
	commit_hash: string;
	manifest: Record<string, any>;
	examples: Array<Record<any, any>>;
}
interface Prompt {
	repo_handle: string;
	description?: string;
	readme?: string;
	id: string;
	tenant_id: string;
	created_at: string;
	updated_at: string;
	is_public: boolean;
	is_archived: boolean;
	tags: string[];
	original_repo_id?: string;
	upstream_repo_id?: string;
	owner?: string;
	full_name: string;
	num_likes: number;
	num_downloads: number;
	num_views: number;
	liked_by_auth_user: boolean;
	last_commit_hash?: string;
	num_commits: number;
	original_repo_full_name?: string;
	upstream_repo_full_name?: string;
}
type PromptSortField = "num_downloads" | "num_views" | "updated_at" | "num_likes";
interface LikePromptResponse {
	likes: number;
}
interface LangSmithSettings {
	id: string;
	display_name: string;
	created_at: string;
	tenant_handle?: string;
}
interface AnnotationQueue {
	/** The unique identifier of the annotation queue. */
	id: string;
	/** The name of the annotation queue. */
	name: string;
	/** An optional description of the annotation queue. */
	description?: string;
	/** The timestamp when the annotation queue was created. */
	created_at: string;
	/** The timestamp when the annotation queue was last updated. */
	updated_at: string;
	/** The ID of the tenant associated with the annotation queue. */
	tenant_id: string;
}
interface RunWithAnnotationQueueInfo extends BaseRun {
	/** The last time this run was reviewed. */
	last_reviewed_time?: string;
	/** The time this run was added to the queue. */
	added_at?: string;
}
interface RunTreeConfig {
	name: string;
	run_type?: string;
	id?: string;
	project_name?: string;
	parent_run?: RunTree;
	parent_run_id?: string;
	child_runs?: RunTree[];
	start_time?: number;
	end_time?: number;
	extra?: KVMap;
	metadata?: KVMap;
	tags?: string[];
	error?: string;
	serialized?: object;
	inputs?: KVMap;
	outputs?: KVMap;
	reference_example_id?: string;
	client?: Client;
	tracingEnabled?: boolean;
	on_end?: (runTree: RunTree) => void;
	execution_order?: number;
	child_execution_order?: number;
	trace_id?: string;
	dotted_order?: string;
	attachments?: Attachments;
}
interface RunnableConfigLike {
	/**
	 * Tags for this call and any sub-calls (eg. a Chain calling an LLM).
	 * You can use these to filter calls.
	 */
	tags?: string[];
	/**
	 * Metadata for this call and any sub-calls (eg. a Chain calling an LLM).
	 * Keys should be strings, values should be JSON-serializable.
	 */
	metadata?: Record<string, unknown>;
	/**
	 * Callbacks for this call and any sub-calls (eg. a Chain calling an LLM).
	 * Tags are passed to all callbacks, metadata is passed to handle*Start callbacks.
	 */
	callbacks?: any;
}
interface HeadersLike {
	get(name: string): string | null;
	set(name: string, value: string): void;
}
declare class RunTree implements BaseRun {
	private static sharedClient;
	id: string;
	name: RunTreeConfig["name"];
	run_type: string;
	project_name: string;
	parent_run?: RunTree;
	child_runs: RunTree[];
	start_time: number;
	end_time?: number;
	extra: KVMap;
	tags?: string[];
	error?: string;
	serialized: object;
	inputs: KVMap;
	outputs?: KVMap;
	reference_example_id?: string;
	client: Client;
	events?: KVMap[] | undefined;
	trace_id: string;
	dotted_order: string;
	tracingEnabled?: boolean;
	execution_order: number;
	child_execution_order: number;
	/**
	 * Attachments associated with the run.
	 * Each entry is a tuple of [mime_type, bytes]
	 */
	attachments?: Attachments;
	constructor(originalConfig: RunTreeConfig | RunTree);
	private static getDefaultConfig;
	private static getSharedClient;
	createChild(config: RunTreeConfig): RunTree;
	end(outputs?: KVMap, error?: string, endTime?: number, metadata?: KVMap): Promise<void>;
	private _convertToCreate;
	postRun(excludeChildRuns?: boolean): Promise<void>;
	patchRun(): Promise<void>;
	toJSON(): RunCreate;
	/**
	 * Add an event to the run tree.
	 * @param event - A single event or string to add
	 */
	addEvent(event: RunEvent | string): void;
	static fromRunnableConfig(parentConfig: RunnableConfigLike, props: RunTreeConfig): RunTree;
	static fromDottedOrder(dottedOrder: string): RunTree | undefined;
	static fromHeaders(headers: Record<string, string | string[]> | HeadersLike, inheritArgs?: RunTreeConfig): RunTree | undefined;
	toHeaders(headers?: HeadersLike): {
		"langsmith-trace": string;
		baggage: string;
	};
}
interface RunEvent {
	name?: string;
	time?: string;
	message?: string;
	kwargs?: Record<string, unknown>;
	[key: string]: unknown;
}
type EvaluationResult = {
	/**
	 * The key associated with the evaluation result.
	 */
	key: string;
	/**
	 * The score of the evaluation result.
	 */
	score?: ScoreType;
	/**
	 * The value of the evaluation result.
	 */
	value?: ValueType;
	/**
	 * A comment associated with the evaluation result.
	 */
	comment?: string;
	/**
	 * A correction record associated with the evaluation result.
	 */
	correction?: Record<string, unknown>;
	/**
	 * Information about the evaluator.
	 */
	evaluatorInfo?: Record<string, unknown>;
	/**
	 * The source run ID of the evaluation result.
	 * If set, a link to the source run will be available in the UI.
	 */
	sourceRunId?: string;
	/**
	 * The target run ID of the evaluation result.
	 * If this is not set, the target run ID is assumed to be
	 * the root of the trace.
	 */
	targetRunId?: string;
	/**
	 * The feedback config associated with the evaluation result.
	 * If set, this will be used to define how a feedback key
	 * should be interpreted.
	 */
	feedbackConfig?: FeedbackConfig;
};
type EvaluationResults = {
	/**
	 * The evaluation results.
	 */
	results: Array<EvaluationResult>;
};
interface RunEvaluator {
	evaluateRun(run: Run, example?: Example, options?: Partial<RunTreeConfig>): Promise<EvaluationResult | EvaluationResults>;
}
interface ClientConfig {
	apiUrl?: string;
	apiKey?: string;
	callerOptions?: AsyncCallerParams;
	timeout_ms?: number;
	webUrl?: string;
	anonymizer?: (values: KVMap) => KVMap | Promise<KVMap>;
	hideInputs?: boolean | ((inputs: KVMap) => KVMap | Promise<KVMap>);
	hideOutputs?: boolean | ((outputs: KVMap) => KVMap | Promise<KVMap>);
	autoBatchTracing?: boolean;
	batchSizeBytesLimit?: number;
	blockOnRootRunFinalization?: boolean;
	traceBatchConcurrency?: number;
	fetchOptions?: RequestInit;
	/**
	 * Whether to require manual .flush() calls before sending traces.
	 * Useful if encountering network rate limits at trace high volumes.
	 */
	manualFlushMode?: boolean;
	tracingSamplingRate?: number;
	/**
	 * Enable debug mode for the client. If set, all sent HTTP requests will be logged.
	 */
	debug?: boolean;
}
interface ListRunsParams {
	/**
	 * The ID or IDs of the project(s) to filter by.
	 */
	projectId?: string | string[];
	/**
	 * The name or names of the project(s) to filter by.
	 */
	projectName?: string | string[];
	/**
	 * The ID of the trace to filter by.
	 */
	traceId?: string;
	/**
	 * isRoot - Whether to only include root runs.
	 *  */
	isRoot?: boolean;
	/**
	 * The execution order to filter by.
	 */
	executionOrder?: number;
	/**
	 * The ID of the parent run to filter by.
	 */
	parentRunId?: string;
	/**
	 * The ID of the reference example to filter by.
	 */
	referenceExampleId?: string;
	/**
	 * The start time to filter by.
	 */
	startTime?: Date;
	/**
	 * The run type to filter by.
	 */
	runType?: string;
	/**
	 * Indicates whether to filter by error runs.
	 */
	error?: boolean;
	/**
	 * The ID or IDs of the runs to filter by.
	 */
	id?: string[];
	/**
	 * The maximum number of runs to retrieve.
	 */
	limit?: number;
	/**
	 * The query string to filter by.
	 */
	query?: string;
	/**
	 * The filter string to apply.
	 *
	 * Run Filtering:
	 * Listing runs with query params is useful for simple queries, but doesn't support many common needs, such as filtering by metadata, tags, or other fields.
	 * LangSmith supports a filter query language to permit more complex filtering operations when fetching runs. This guide will provide a high level overview of the grammar as well as a few examples of when it can be useful.
	 * If you'd prefer a more visual guide, you can get a taste of the language by viewing the table of runs on any of your projects' pages. We provide some recommended filters to get you started that you can copy and use the SDK.
	 *
	 * Grammar:
	 * The filtering grammar is based on common comparators on fields in the run object. Supported comparators include:
	 * - gte (greater than or equal to)
	 * - gt (greater than)
	 * - lte (less than or equal to)
	 * - lt (less than)
	 * - eq (equal to)
	 * - neq (not equal to)
	 * - has (check if run contains a tag or metadata json blob)
	 * - search (search for a substring in a string field)
	 */
	filter?: string;
	/**
	 * Filter to apply to the ROOT run in the trace tree. This is meant to be used in conjunction with the regular
	 *  `filter` parameter to let you filter runs by attributes of the root run within a trace. Example is filtering by
	 * feedback assigned to the trace.
	 */
	traceFilter?: string;
	/**
	 * Filter to apply to OTHER runs in the trace tree, including sibling and child runs. This is meant to be used in
	 * conjunction with the regular `filter` parameter to let you filter runs by attributes of any run within a trace.
	 */
	treeFilter?: string;
	/**
	 * The values to include in the response.
	 */
	select?: string[];
}
interface UploadCSVParams {
	csvFile: Blob;
	fileName: string;
	inputKeys: string[];
	outputKeys: string[];
	description?: string;
	dataType?: DataType;
	name?: string;
}
interface CreateRunParams {
	name: string;
	inputs: KVMap;
	run_type: string;
	id?: string;
	start_time?: number;
	end_time?: number;
	extra?: KVMap;
	error?: string;
	serialized?: object;
	outputs?: KVMap;
	reference_example_id?: string;
	child_runs?: RunCreate[];
	parent_run_id?: string;
	project_name?: string;
	revision_id?: string;
	trace_id?: string;
	dotted_order?: string;
	attachments?: Attachments;
}
interface ProjectOptions {
	projectName?: string;
	projectId?: string;
}
type RecordStringAny = Record<string, any>;
type FeedbackSourceType = "model" | "api" | "app";
type CreateExampleOptions = {
	/** The ID of the dataset to create the example in. */
	datasetId?: string;
	/** The name of the dataset to create the example in (if dataset ID is not provided). */
	datasetName?: string;
	/** The creation date of the example. */
	createdAt?: Date;
	/** A unique identifier for the example. */
	exampleId?: string;
	/** Additional metadata associated with the example. */
	metadata?: KVMap;
	/** The split(s) to assign the example to. */
	split?: string | string[];
	/** The ID of the source run associated with this example. */
	sourceRunId?: string;
	/** Whether to use the inputs and outputs from the source run. */
	useSourceRunIO?: boolean;
	/** Which attachments from the source run to use. */
	useSourceRunAttachments?: string[];
	/** Attachments for the example */
	attachments?: Attachments;
};
type CreateProjectParams = {
	projectName: string;
	description?: string | null;
	metadata?: RecordStringAny | null;
	upsert?: boolean;
	projectExtra?: RecordStringAny | null;
	referenceDatasetId?: string | null;
};
declare class Client implements LangSmithTracingClientInterface {
	private apiKey?;
	private apiUrl;
	private webUrl?;
	private caller;
	private batchIngestCaller;
	private timeout_ms;
	private _tenantId;
	private hideInputs?;
	private hideOutputs?;
	private tracingSampleRate?;
	private filteredPostUuids;
	private autoBatchTracing;
	private autoBatchQueue;
	private autoBatchTimeout;
	private autoBatchAggregationDelayMs;
	private batchSizeBytesLimit?;
	private fetchOptions;
	private settings;
	private blockOnRootRunFinalization;
	private traceBatchConcurrency;
	private _serverInfo;
	private _getServerInfoPromise?;
	private manualFlushMode;
	debug: boolean;
	constructor(config?: ClientConfig);
	static getDefaultClientConfig(): {
		apiUrl: string;
		apiKey?: string;
		webUrl?: string;
		hideInputs?: boolean;
		hideOutputs?: boolean;
	};
	getHostUrl(): string;
	private get headers();
	private processInputs;
	private processOutputs;
	private prepareRunCreateOrUpdateInputs;
	private _getResponse;
	private _get;
	private _getPaginated;
	private _getCursorPaginatedList;
	private _shouldSample;
	private _filterForSampling;
	private _getBatchSizeLimitBytes;
	private _getMultiPartSupport;
	private drainAutoBatchQueue;
	private _processBatch;
	private processRunOperation;
	protected _getServerInfo(): Promise<any>;
	protected _ensureServerInfo(): Promise<Record<string, any>>;
	protected _getSettings(): Promise<LangSmithSettings>;
	/**
	 * Flushes current queued traces.
	 */
	flush(): Promise<void>;
	createRun(run: CreateRunParams): Promise<void>;
	/**
	 * Batch ingest/upsert multiple runs in the Langsmith system.
	 * @param runs
	 */
	batchIngestRuns({ runCreates, runUpdates, }: {
		runCreates?: RunCreate[];
		runUpdates?: RunUpdate[];
	}): Promise<void>;
	private _postBatchIngestRuns;
	/**
	 * Batch ingest/upsert multiple runs in the Langsmith system.
	 * @param runs
	 */
	multipartIngestRuns({ runCreates, runUpdates, }: {
		runCreates?: RunCreate[];
		runUpdates?: RunUpdate[];
	}): Promise<void>;
	private _sendMultipartRequest;
	updateRun(runId: string, run: RunUpdate): Promise<void>;
	readRun(runId: string, { loadChildRuns }?: {
		loadChildRuns: boolean;
	}): Promise<Run>;
	getRunUrl({ runId, run, projectOpts, }: {
		runId?: string;
		run?: Run;
		projectOpts?: ProjectOptions;
	}): Promise<string>;
	private _loadChildRuns;
	/**
	 * List runs from the LangSmith server.
	 * @param projectId - The ID of the project to filter by.
	 * @param projectName - The name of the project to filter by.
	 * @param parentRunId - The ID of the parent run to filter by.
	 * @param traceId - The ID of the trace to filter by.
	 * @param referenceExampleId - The ID of the reference example to filter by.
	 * @param startTime - The start time to filter by.
	 * @param isRoot - Indicates whether to only return root runs.
	 * @param runType - The run type to filter by.
	 * @param error - Indicates whether to filter by error runs.
	 * @param id - The ID of the run to filter by.
	 * @param query - The query string to filter by.
	 * @param filter - The filter string to apply to the run spans.
	 * @param traceFilter - The filter string to apply on the root run of the trace.
	 * @param treeFilter - The filter string to apply on other runs in the trace.
	 * @param limit - The maximum number of runs to retrieve.
	 * @returns {AsyncIterable<Run>} - The runs.
	 *
	 * @example
	 * // List all runs in a project
	 * const projectRuns = client.listRuns({ projectName: "<your_project>" });
	 *
	 * @example
	 * // List LLM and Chat runs in the last 24 hours
	 * const todaysLLMRuns = client.listRuns({
	 *   projectName: "<your_project>",
	 *   start_time: new Date(Date.now() - 24 * 60 * 60 * 1000),
	 *   run_type: "llm",
	 * });
	 *
	 * @example
	 * // List traces in a project
	 * const rootRuns = client.listRuns({
	 *   projectName: "<your_project>",
	 *   execution_order: 1,
	 * });
	 *
	 * @example
	 * // List runs without errors
	 * const correctRuns = client.listRuns({
	 *   projectName: "<your_project>",
	 *   error: false,
	 * });
	 *
	 * @example
	 * // List runs by run ID
	 * const runIds = [
	 *   "a36092d2-4ad5-4fb4-9c0d-0dba9a2ed836",
	 *   "9398e6be-964f-4aa4-8ae9-ad78cd4b7074",
	 * ];
	 * const selectedRuns = client.listRuns({ run_ids: runIds });
	 *
	 * @example
	 * // List all "chain" type runs that took more than 10 seconds and had `total_tokens` greater than 5000
	 * const chainRuns = client.listRuns({
	 *   projectName: "<your_project>",
	 *   filter: 'and(eq(run_type, "chain"), gt(latency, 10), gt(total_tokens, 5000))',
	 * });
	 *
	 * @example
	 * // List all runs called "extractor" whose root of the trace was assigned feedback "user_score" score of 1
	 * const goodExtractorRuns = client.listRuns({
	 *   projectName: "<your_project>",
	 *   filter: 'eq(name, "extractor")',
	 *   traceFilter: 'and(eq(feedback_key, "user_score"), eq(feedback_score, 1))',
	 * });
	 *
	 * @example
	 * // List all runs that started after a specific timestamp and either have "error" not equal to null or a "Correctness" feedback score equal to 0
	 * const complexRuns = client.listRuns({
	 *   projectName: "<your_project>",
	 *   filter: 'and(gt(start_time, "2023-07-15T12:34:56Z"), or(neq(error, null), and(eq(feedback_key, "Correctness"), eq(feedback_score, 0.0))))',
	 * });
	 *
	 * @example
	 * // List all runs where `tags` include "experimental" or "beta" and `latency` is greater than 2 seconds
	 * const taggedRuns = client.listRuns({
	 *   projectName: "<your_project>",
	 *   filter: 'and(or(has(tags, "experimental"), has(tags, "beta")), gt(latency, 2))',
	 * });
	 */
	listRuns(props: ListRunsParams): AsyncIterable<Run>;
	getRunStats({ id, trace, parentRun, runType, projectNames, projectIds, referenceExampleIds, startTime, endTime, error, query, filter, traceFilter, treeFilter, isRoot, dataSourceType, }: {
		id?: string[];
		trace?: string;
		parentRun?: string;
		runType?: string;
		projectNames?: string[];
		projectIds?: string[];
		referenceExampleIds?: string[];
		startTime?: string;
		endTime?: string;
		error?: boolean;
		query?: string;
		filter?: string;
		traceFilter?: string;
		treeFilter?: string;
		isRoot?: boolean;
		dataSourceType?: string;
	}): Promise<any>;
	shareRun(runId: string, { shareId }?: {
		shareId?: string;
	}): Promise<string>;
	unshareRun(runId: string): Promise<void>;
	readRunSharedLink(runId: string): Promise<string | undefined>;
	listSharedRuns(shareToken: string, { runIds, }?: {
		runIds?: string[];
	}): Promise<Run[]>;
	readDatasetSharedSchema(datasetId?: string, datasetName?: string): Promise<DatasetShareSchema>;
	shareDataset(datasetId?: string, datasetName?: string): Promise<DatasetShareSchema>;
	unshareDataset(datasetId: string): Promise<void>;
	readSharedDataset(shareToken: string): Promise<Dataset>;
	/**
	 * Get shared examples.
	 *
	 * @param {string} shareToken The share token to get examples for. A share token is the UUID (or LangSmith URL, including UUID) generated when explicitly marking an example as public.
	 * @param {Object} [options] Additional options for listing the examples.
	 * @param {string[] | undefined} [options.exampleIds] A list of example IDs to filter by.
	 * @returns {Promise<Example[]>} The shared examples.
	 */
	listSharedExamples(shareToken: string, options?: {
		exampleIds?: string[];
	}): Promise<Example[]>;
	createProject({ projectName, description, metadata, upsert, projectExtra, referenceDatasetId, }: CreateProjectParams): Promise<TracerSession>;
	updateProject(projectId: string, { name, description, metadata, projectExtra, endTime, }: {
		name?: string | null;
		description?: string | null;
		metadata?: RecordStringAny | null;
		projectExtra?: RecordStringAny | null;
		endTime?: string | null;
	}): Promise<TracerSession>;
	hasProject({ projectId, projectName, }: {
		projectId?: string;
		projectName?: string;
	}): Promise<boolean>;
	readProject({ projectId, projectName, includeStats, }: {
		projectId?: string;
		projectName?: string;
		includeStats?: boolean;
	}): Promise<TracerSessionResult>;
	getProjectUrl({ projectId, projectName, }: {
		projectId?: string;
		projectName?: string;
	}): Promise<string>;
	getDatasetUrl({ datasetId, datasetName, }: {
		datasetId?: string;
		datasetName?: string;
	}): Promise<string>;
	private _getTenantId;
	listProjects({ projectIds, name, nameContains, referenceDatasetId, referenceDatasetName, referenceFree, metadata, }?: {
		projectIds?: string[];
		name?: string;
		nameContains?: string;
		referenceDatasetId?: string;
		referenceDatasetName?: string;
		referenceFree?: boolean;
		metadata?: RecordStringAny;
	}): AsyncIterable<TracerSession>;
	deleteProject({ projectId, projectName, }: {
		projectId?: string;
		projectName?: string;
	}): Promise<void>;
	uploadCsv({ csvFile, fileName, inputKeys, outputKeys, description, dataType, name, }: UploadCSVParams): Promise<Dataset>;
	createDataset(name: string, { description, dataType, inputsSchema, outputsSchema, metadata, }?: {
		description?: string;
		dataType?: DataType;
		inputsSchema?: KVMap;
		outputsSchema?: KVMap;
		metadata?: RecordStringAny;
	}): Promise<Dataset>;
	readDataset({ datasetId, datasetName, }: {
		datasetId?: string;
		datasetName?: string;
	}): Promise<Dataset>;
	hasDataset({ datasetId, datasetName, }: {
		datasetId?: string;
		datasetName?: string;
	}): Promise<boolean>;
	diffDatasetVersions({ datasetId, datasetName, fromVersion, toVersion, }: {
		datasetId?: string;
		datasetName?: string;
		fromVersion: string | Date;
		toVersion: string | Date;
	}): Promise<DatasetDiffInfo>;
	readDatasetOpenaiFinetuning({ datasetId, datasetName, }: {
		datasetId?: string;
		datasetName?: string;
	}): Promise<any[]>;
	listDatasets({ limit, offset, datasetIds, datasetName, datasetNameContains, metadata, }?: {
		limit?: number;
		offset?: number;
		datasetIds?: string[];
		datasetName?: string;
		datasetNameContains?: string;
		metadata?: RecordStringAny;
	}): AsyncIterable<Dataset>;
	/**
	 * Update a dataset
	 * @param props The dataset details to update
	 * @returns The updated dataset
	 */
	updateDataset(props: {
		datasetId?: string;
		datasetName?: string;
		name?: string;
		description?: string;
	}): Promise<Dataset>;
	/**
	 * Updates a tag on a dataset.
	 *
	 * If the tag is already assigned to a different version of this dataset,
	 * the tag will be moved to the new version. The as_of parameter is used to
	 * determine which version of the dataset to apply the new tags to.
	 *
	 * It must be an exact version of the dataset to succeed. You can
	 * use the "readDatasetVersion" method to find the exact version
	 * to apply the tags to.
	 * @param params.datasetId The ID of the dataset to update. Must be provided if "datasetName" is not provided.
	 * @param params.datasetName The name of the dataset to update. Must be provided if "datasetId" is not provided.
	 * @param params.asOf The timestamp of the dataset to apply the new tags to.
	 * @param params.tag The new tag to apply to the dataset.
	 */
	updateDatasetTag(props: {
		datasetId?: string;
		datasetName?: string;
		asOf: string | Date;
		tag: string;
	}): Promise<void>;
	deleteDataset({ datasetId, datasetName, }: {
		datasetId?: string;
		datasetName?: string;
	}): Promise<void>;
	indexDataset({ datasetId, datasetName, tag, }: {
		datasetId?: string;
		datasetName?: string;
		tag?: string;
	}): Promise<void>;
	/**
	 * Lets you run a similarity search query on a dataset.
	 *
	 * Requires the dataset to be indexed. Please see the `indexDataset` method to set up indexing.
	 *
	 * @param inputs      The input on which to run the similarity search. Must have the
	 *                    same schema as the dataset.
	 *
	 * @param datasetId   The dataset to search for similar examples.
	 *
	 * @param limit       The maximum number of examples to return. Will return the top `limit` most
	 *                    similar examples in order of most similar to least similar. If no similar
	 *                    examples are found, random examples will be returned.
	 *
	 * @param filter      A filter string to apply to the search. Only examples will be returned that
	 *                    match the filter string. Some examples of filters
	 *
	 *                    - eq(metadata.mykey, "value")
	 *                    - and(neq(metadata.my.nested.key, "value"), neq(metadata.mykey, "value"))
	 *                    - or(eq(metadata.mykey, "value"), eq(metadata.mykey, "othervalue"))
	 *
	 * @returns           A list of similar examples.
	 *
	 *
	 * @example
	 * dataset_id = "123e4567-e89b-12d3-a456-426614174000"
	 * inputs = {"text": "How many people live in Berlin?"}
	 * limit = 5
	 * examples = await client.similarExamples(inputs, dataset_id, limit)
	 */
	similarExamples(inputs: KVMap, datasetId: string, limit: number, { filter, }?: {
		filter?: string;
	}): Promise<ExampleSearch[]>;
	createExample(update: ExampleCreate): Promise<Example>;
	/**
	 * @deprecated This signature is deprecated, use createExample(update: ExampleCreate) instead
	 */
	createExample(inputs: KVMap, outputs: KVMap, options: CreateExampleOptions): Promise<Example>;
	createExamples(uploads: ExampleCreate[]): Promise<Example[]>;
	/** @deprecated Use the uploads-only overload instead */
	createExamples(props: {
		inputs?: Array<KVMap>;
		outputs?: Array<KVMap>;
		metadata?: Array<KVMap>;
		splits?: Array<string | Array<string>>;
		sourceRunIds?: Array<string>;
		useSourceRunIOs?: Array<boolean>;
		useSourceRunAttachments?: Array<string[]>;
		attachments?: Array<Attachments>;
		exampleIds?: Array<string>;
		datasetId?: string;
		datasetName?: string;
	}): Promise<Example[]>;
	createLLMExample(input: string, generation: string | undefined, options: CreateExampleOptions): Promise<Example>;
	createChatExample(input: KVMap[] | LangChainBaseMessage[], generations: KVMap | LangChainBaseMessage | undefined, options: CreateExampleOptions): Promise<Example>;
	readExample(exampleId: string): Promise<Example>;
	listExamples({ datasetId, datasetName, exampleIds, asOf, splits, inlineS3Urls, metadata, limit, offset, filter, includeAttachments, }?: {
		datasetId?: string;
		datasetName?: string;
		exampleIds?: string[];
		asOf?: string | Date;
		splits?: string[];
		inlineS3Urls?: boolean;
		metadata?: KVMap;
		limit?: number;
		offset?: number;
		filter?: string;
		includeAttachments?: boolean;
	}): AsyncIterable<Example>;
	deleteExample(exampleId: string): Promise<void>;
	/**
	 * @deprecated This signature is deprecated, use updateExample(update: ExampleUpdate) instead
	 */
	updateExample(exampleId: string, update: ExampleUpdateWithoutId): Promise<object>;
	updateExample(update: ExampleUpdate): Promise<object>;
	updateExamples(update: ExampleUpdate[]): Promise<object>;
	/**
	 * Get dataset version by closest date or exact tag.
	 *
	 * Use this to resolve the nearest version to a given timestamp or for a given tag.
	 *
	 * @param options The options for getting the dataset version
	 * @param options.datasetId The ID of the dataset
	 * @param options.datasetName The name of the dataset
	 * @param options.asOf The timestamp of the dataset to retrieve
	 * @param options.tag The tag of the dataset to retrieve
	 * @returns The dataset version
	 */
	readDatasetVersion({ datasetId, datasetName, asOf, tag, }: {
		datasetId?: string;
		datasetName?: string;
		asOf?: string | Date;
		tag?: string;
	}): Promise<DatasetVersion>;
	listDatasetSplits({ datasetId, datasetName, asOf, }: {
		datasetId?: string;
		datasetName?: string;
		asOf?: string | Date;
	}): Promise<string[]>;
	updateDatasetSplits({ datasetId, datasetName, splitName, exampleIds, remove, }: {
		datasetId?: string;
		datasetName?: string;
		splitName: string;
		exampleIds: string[];
		remove?: boolean;
	}): Promise<void>;
	/**
	 * @deprecated This method is deprecated and will be removed in future LangSmith versions, use `evaluate` from `langsmith/evaluation` instead.
	 */
	evaluateRun(run: Run | string, evaluator: RunEvaluator, { sourceInfo, loadChildRuns, referenceExample, }?: {
		sourceInfo?: KVMap;
		loadChildRuns: boolean;
		referenceExample?: Example;
	}): Promise<Feedback>;
	createFeedback(runId: string | null, key: string, { score, value, correction, comment, sourceInfo, feedbackSourceType, sourceRunId, feedbackId, feedbackConfig, projectId, comparativeExperimentId, }: {
		score?: ScoreType;
		value?: ValueType;
		correction?: object;
		comment?: string;
		sourceInfo?: object;
		feedbackSourceType?: FeedbackSourceType;
		feedbackConfig?: FeedbackConfig;
		sourceRunId?: string;
		feedbackId?: string;
		eager?: boolean;
		projectId?: string;
		comparativeExperimentId?: string;
	}): Promise<Feedback>;
	updateFeedback(feedbackId: string, { score, value, correction, comment, }: {
		score?: number | boolean | null;
		value?: number | boolean | string | object | null;
		correction?: object | null;
		comment?: string | null;
	}): Promise<void>;
	readFeedback(feedbackId: string): Promise<Feedback>;
	deleteFeedback(feedbackId: string): Promise<void>;
	listFeedback({ runIds, feedbackKeys, feedbackSourceTypes, }?: {
		runIds?: string[];
		feedbackKeys?: string[];
		feedbackSourceTypes?: FeedbackSourceType[];
	}): AsyncIterable<Feedback>;
	/**
	 * Creates a presigned feedback token and URL.
	 *
	 * The token can be used to authorize feedback metrics without
	 * needing an API key. This is useful for giving browser-based
	 * applications the ability to submit feedback without needing
	 * to expose an API key.
	 *
	 * @param runId The ID of the run.
	 * @param feedbackKey The feedback key.
	 * @param options Additional options for the token.
	 * @param options.expiration The expiration time for the token.
	 *
	 * @returns A promise that resolves to a FeedbackIngestToken.
	 */
	createPresignedFeedbackToken(runId: string, feedbackKey: string, { expiration, feedbackConfig, }?: {
		expiration?: string | TimeDelta;
		feedbackConfig?: FeedbackConfig;
	}): Promise<FeedbackIngestToken>;
	createComparativeExperiment({ name, experimentIds, referenceDatasetId, createdAt, description, metadata, id, }: {
		name: string;
		experimentIds: Array<string>;
		referenceDatasetId?: string;
		createdAt?: Date;
		description?: string;
		metadata?: Record<string, unknown>;
		id?: string;
	}): Promise<ComparativeExperiment>;
	/**
	 * Retrieves a list of presigned feedback tokens for a given run ID.
	 * @param runId The ID of the run.
	 * @returns An async iterable of FeedbackIngestToken objects.
	 */
	listPresignedFeedbackTokens(runId: string): AsyncIterable<FeedbackIngestToken>;
	_selectEvalResults(results: EvaluationResult | EvaluationResult[] | EvaluationResults): Array<EvaluationResult>;
	_logEvaluationFeedback(evaluatorResponse: EvaluationResult | EvaluationResult[] | EvaluationResults, run?: Run, sourceInfo?: {
		[key: string]: any;
	}): Promise<[
		results: EvaluationResult[],
		feedbacks: Feedback[]
	]>;
	logEvaluationFeedback(evaluatorResponse: EvaluationResult | EvaluationResult[] | EvaluationResults, run?: Run, sourceInfo?: {
		[key: string]: any;
	}): Promise<EvaluationResult[]>;
	/**
	 * API for managing annotation queues
	 */
	/**
	 * List the annotation queues on the LangSmith API.
	 * @param options - The options for listing annotation queues
	 * @param options.queueIds - The IDs of the queues to filter by
	 * @param options.name - The name of the queue to filter by
	 * @param options.nameContains - The substring that the queue name should contain
	 * @param options.limit - The maximum number of queues to return
	 * @returns An iterator of AnnotationQueue objects
	 */
	listAnnotationQueues(options?: {
		queueIds?: string[];
		name?: string;
		nameContains?: string;
		limit?: number;
	}): AsyncIterableIterator<AnnotationQueue>;
	/**
	 * Create an annotation queue on the LangSmith API.
	 * @param options - The options for creating an annotation queue
	 * @param options.name - The name of the annotation queue
	 * @param options.description - The description of the annotation queue
	 * @param options.queueId - The ID of the annotation queue
	 * @returns The created AnnotationQueue object
	 */
	createAnnotationQueue(options: {
		name: string;
		description?: string;
		queueId?: string;
	}): Promise<AnnotationQueue>;
	/**
	 * Read an annotation queue with the specified queue ID.
	 * @param queueId - The ID of the annotation queue to read
	 * @returns The AnnotationQueue object
	 */
	readAnnotationQueue(queueId: string): Promise<AnnotationQueue>;
	/**
	 * Update an annotation queue with the specified queue ID.
	 * @param queueId - The ID of the annotation queue to update
	 * @param options - The options for updating the annotation queue
	 * @param options.name - The new name for the annotation queue
	 * @param options.description - The new description for the annotation queue
	 */
	updateAnnotationQueue(queueId: string, options: {
		name: string;
		description?: string;
	}): Promise<void>;
	/**
	 * Delete an annotation queue with the specified queue ID.
	 * @param queueId - The ID of the annotation queue to delete
	 */
	deleteAnnotationQueue(queueId: string): Promise<void>;
	/**
	 * Add runs to an annotation queue with the specified queue ID.
	 * @param queueId - The ID of the annotation queue
	 * @param runIds - The IDs of the runs to be added to the annotation queue
	 */
	addRunsToAnnotationQueue(queueId: string, runIds: string[]): Promise<void>;
	/**
	 * Get a run from an annotation queue at the specified index.
	 * @param queueId - The ID of the annotation queue
	 * @param index - The index of the run to retrieve
	 * @returns A Promise that resolves to a RunWithAnnotationQueueInfo object
	 * @throws {Error} If the run is not found at the given index or for other API-related errors
	 */
	getRunFromAnnotationQueue(queueId: string, index: number): Promise<RunWithAnnotationQueueInfo>;
	/**
	 * Delete a run from an an annotation queue.
	 * @param queueId - The ID of the annotation queue to delete the run from
	 * @param queueRunId - The ID of the run to delete from the annotation queue
	 */
	deleteRunFromAnnotationQueue(queueId: string, queueRunId: string): Promise<void>;
	/**
	 * Get the size of an annotation queue.
	 * @param queueId - The ID of the annotation queue
	 */
	getSizeFromAnnotationQueue(queueId: string): Promise<{
		size: number;
	}>;
	protected _currentTenantIsOwner(owner: string): Promise<boolean>;
	protected _ownerConflictError(action: string, owner: string): Promise<Error>;
	protected _getLatestCommitHash(promptOwnerAndName: string): Promise<string | undefined>;
	protected _likeOrUnlikePrompt(promptIdentifier: string, like: boolean): Promise<LikePromptResponse>;
	protected _getPromptUrl(promptIdentifier: string): Promise<string>;
	promptExists(promptIdentifier: string): Promise<boolean>;
	likePrompt(promptIdentifier: string): Promise<LikePromptResponse>;
	unlikePrompt(promptIdentifier: string): Promise<LikePromptResponse>;
	listCommits(promptOwnerAndName: string): AsyncIterableIterator<PromptCommit>;
	listPrompts(options?: {
		isPublic?: boolean;
		isArchived?: boolean;
		sortField?: PromptSortField;
		query?: string;
	}): AsyncIterableIterator<Prompt>;
	getPrompt(promptIdentifier: string): Promise<Prompt | null>;
	createPrompt(promptIdentifier: string, options?: {
		description?: string;
		readme?: string;
		tags?: string[];
		isPublic?: boolean;
	}): Promise<Prompt>;
	createCommit(promptIdentifier: string, object: any, options?: {
		parentCommitHash?: string;
	}): Promise<string>;
	/**
	 * Update examples with attachments using multipart form data.
	 * @param updates List of ExampleUpdateWithAttachments objects to upsert
	 * @returns Promise with the update response
	 */
	updateExamplesMultipart(datasetId: string, updates?: ExampleUpdate[]): Promise<UpdateExamplesResponse>;
	private _updateExamplesMultipart;
	/**
	 * Upload examples with attachments using multipart form data.
	 * @param uploads List of ExampleUploadWithAttachments objects to upload
	 * @returns Promise with the upload response
	 * @deprecated This method is deprecated and will be removed in future LangSmith versions, please use `createExamples` instead
	 */
	uploadExamplesMultipart(datasetId: string, uploads?: ExampleCreate[]): Promise<UploadExamplesResponse>;
	private _uploadExamplesMultipart;
	updatePrompt(promptIdentifier: string, options?: {
		description?: string;
		readme?: string;
		tags?: string[];
		isPublic?: boolean;
		isArchived?: boolean;
	}): Promise<Record<string, any>>;
	deletePrompt(promptIdentifier: string): Promise<void>;
	pullPromptCommit(promptIdentifier: string, options?: {
		includeModel?: boolean;
	}): Promise<PromptCommit>;
	/**
	 * This method should not be used directly, use `import { pull } from "langchain/hub"` instead.
	 * Using this method directly returns the JSON string of the prompt rather than a LangChain object.
	 * @private
	 */
	_pullPrompt(promptIdentifier: string, options?: {
		includeModel?: boolean;
	}): Promise<any>;
	pushPrompt(promptIdentifier: string, options?: {
		object?: any;
		parentCommitHash?: string;
		isPublic?: boolean;
		description?: string;
		readme?: string;
		tags?: string[];
	}): Promise<string>;
	/**
	 * Clone a public dataset to your own langsmith tenant.
	 * This operation is idempotent. If you already have a dataset with the given name,
	 * this function will do nothing.
  
	 * @param {string} tokenOrUrl The token of the public dataset to clone.
	 * @param {Object} [options] Additional options for cloning the dataset.
	 * @param {string} [options.sourceApiUrl] The URL of the langsmith server where the data is hosted. Defaults to the API URL of your current client.
	 * @param {string} [options.datasetName] The name of the dataset to create in your tenant. Defaults to the name of the public dataset.
	 * @returns {Promise<void>}
	 */
	clonePublicDataset(tokenOrUrl: string, options?: {
		sourceApiUrl?: string;
		datasetName?: string;
	}): Promise<void>;
	private parseTokenOrUrl;
	/**
	 * Awaits all pending trace batches. Useful for environments where
	 * you need to be sure that all tracing requests finish before execution ends,
	 * such as serverless environments.
	 *
	 * @example
	 * ```
	 * import { Client } from "langsmith";
	 *
	 * const client = new Client();
	 *
	 * try {
	 *   // Tracing happens here
	 *   ...
	 * } finally {
	 *   await client.awaitPendingTraceBatches();
	 * }
	 * ```
	 *
	 * @returns A promise that resolves once all currently pending traces have sent.
	 */
	awaitPendingTraceBatches(): Promise<void> | Promise<[
		...void[],
		void
	]>;
}
interface LangSmithTracingClientInterface {
	createRun: (run: CreateRunParams) => Promise<void>;
	updateRun: (runId: string, run: RunUpdate) => Promise<void>;
}
interface Run$1 extends BaseRun {
	id: string;
	start_time: number;
	execution_order: number;
	child_runs: this[];
	child_execution_order: number;
	events: Array<{
		name: string;
		time: string;
		kwargs?: Record<string, unknown>;
	}>;
	trace_id?: string;
	dotted_order?: string;
}
declare abstract class BaseTracer extends BaseCallbackHandler {
	protected runMap: Map<string, Run$1>;
	constructor(_fields?: BaseCallbackHandlerInput);
	copy(): this;
	protected stringifyError(error: unknown): string;
	protected abstract persistRun(run: Run$1): Promise<void>;
	protected _addChildRun(parentRun: Run$1, childRun: Run$1): void;
	_addRunToRunMap(run: Run$1): {
		id: string;
		start_time: number;
		execution_order: number;
		child_runs: Run$1[];
		child_execution_order: number;
		events: {
			name: string;
			time: string;
			kwargs?: Record<string, unknown> | undefined;
		}[];
		trace_id?: string | undefined;
		dotted_order?: string | undefined;
		name: string;
		run_type: string;
		end_time?: number | undefined;
		extra?: KVMap | undefined;
		error?: string | undefined;
		serialized?: object | undefined;
		inputs: KVMap;
		outputs?: KVMap | undefined;
		reference_example_id?: string | undefined;
		parent_run_id?: string | undefined;
		tags?: string[] | undefined;
		attachments?: Attachments | undefined;
	};
	protected _endTrace(run: Run$1): Promise<void>;
	protected _getExecutionOrder(parentRunId: string | undefined): number;
	/**
	 * Create and add a run to the run map for LLM start events.
	 * This must sometimes be done synchronously to avoid race conditions
	 * when callbacks are backgrounded, so we expose it as a separate method here.
	 */
	_createRunForLLMStart(llm: Serialized, prompts: string[], runId: string, parentRunId?: string, extraParams?: KVMap, tags?: string[], metadata?: KVMap, name?: string): {
		id: string;
		start_time: number;
		execution_order: number;
		child_runs: Run$1[];
		child_execution_order: number;
		events: {
			name: string;
			time: string;
			kwargs?: Record<string, unknown> | undefined;
		}[];
		trace_id?: string | undefined;
		dotted_order?: string | undefined;
		name: string;
		run_type: string;
		end_time?: number | undefined;
		extra?: KVMap | undefined;
		error?: string | undefined;
		serialized?: object | undefined;
		inputs: KVMap;
		outputs?: KVMap | undefined;
		reference_example_id?: string | undefined;
		parent_run_id?: string | undefined;
		tags?: string[] | undefined;
		attachments?: Attachments | undefined;
	};
	handleLLMStart(llm: Serialized, prompts: string[], runId: string, parentRunId?: string, extraParams?: KVMap, tags?: string[], metadata?: KVMap, name?: string): Promise<Run$1>;
	/**
	 * Create and add a run to the run map for chat model start events.
	 * This must sometimes be done synchronously to avoid race conditions
	 * when callbacks are backgrounded, so we expose it as a separate method here.
	 */
	_createRunForChatModelStart(llm: Serialized, messages: BaseMessage[][], runId: string, parentRunId?: string, extraParams?: KVMap, tags?: string[], metadata?: KVMap, name?: string): {
		id: string;
		start_time: number;
		execution_order: number;
		child_runs: Run$1[];
		child_execution_order: number;
		events: {
			name: string;
			time: string;
			kwargs?: Record<string, unknown> | undefined;
		}[];
		trace_id?: string | undefined;
		dotted_order?: string | undefined;
		name: string;
		run_type: string;
		end_time?: number | undefined;
		extra?: KVMap | undefined;
		error?: string | undefined;
		serialized?: object | undefined;
		inputs: KVMap;
		outputs?: KVMap | undefined;
		reference_example_id?: string | undefined;
		parent_run_id?: string | undefined;
		tags?: string[] | undefined;
		attachments?: Attachments | undefined;
	};
	handleChatModelStart(llm: Serialized, messages: BaseMessage[][], runId: string, parentRunId?: string, extraParams?: KVMap, tags?: string[], metadata?: KVMap, name?: string): Promise<Run$1>;
	handleLLMEnd(output: LLMResult, runId: string, _parentRunId?: string, _tags?: string[], extraParams?: Record<string, unknown>): Promise<Run$1>;
	handleLLMError(error: unknown, runId: string, _parentRunId?: string, _tags?: string[], extraParams?: Record<string, unknown>): Promise<Run$1>;
	/**
	 * Create and add a run to the run map for chain start events.
	 * This must sometimes be done synchronously to avoid race conditions
	 * when callbacks are backgrounded, so we expose it as a separate method here.
	 */
	_createRunForChainStart(chain: Serialized, inputs: ChainValues, runId: string, parentRunId?: string, tags?: string[], metadata?: KVMap, runType?: string, name?: string): {
		id: string;
		start_time: number;
		execution_order: number;
		child_runs: Run$1[];
		child_execution_order: number;
		events: {
			name: string;
			time: string;
			kwargs?: Record<string, unknown> | undefined;
		}[];
		trace_id?: string | undefined;
		dotted_order?: string | undefined;
		name: string;
		run_type: string;
		end_time?: number | undefined;
		extra?: KVMap | undefined;
		error?: string | undefined;
		serialized?: object | undefined;
		inputs: KVMap;
		outputs?: KVMap | undefined;
		reference_example_id?: string | undefined;
		parent_run_id?: string | undefined;
		tags?: string[] | undefined;
		attachments?: Attachments | undefined;
	};
	handleChainStart(chain: Serialized, inputs: ChainValues, runId: string, parentRunId?: string, tags?: string[], metadata?: KVMap, runType?: string, name?: string): Promise<Run$1>;
	handleChainEnd(outputs: ChainValues, runId: string, _parentRunId?: string, _tags?: string[], kwargs?: {
		inputs?: Record<string, unknown>;
	}): Promise<Run$1>;
	handleChainError(error: unknown, runId: string, _parentRunId?: string, _tags?: string[], kwargs?: {
		inputs?: Record<string, unknown>;
	}): Promise<Run$1>;
	/**
	 * Create and add a run to the run map for tool start events.
	 * This must sometimes be done synchronously to avoid race conditions
	 * when callbacks are backgrounded, so we expose it as a separate method here.
	 */
	_createRunForToolStart(tool: Serialized, input: string, runId: string, parentRunId?: string, tags?: string[], metadata?: KVMap, name?: string): {
		id: string;
		start_time: number;
		execution_order: number;
		child_runs: Run$1[];
		child_execution_order: number;
		events: {
			name: string;
			time: string;
			kwargs?: Record<string, unknown> | undefined;
		}[];
		trace_id?: string | undefined;
		dotted_order?: string | undefined;
		name: string;
		run_type: string;
		end_time?: number | undefined;
		extra?: KVMap | undefined;
		error?: string | undefined;
		serialized?: object | undefined;
		inputs: KVMap;
		outputs?: KVMap | undefined;
		reference_example_id?: string | undefined;
		parent_run_id?: string | undefined;
		tags?: string[] | undefined;
		attachments?: Attachments | undefined;
	};
	handleToolStart(tool: Serialized, input: string, runId: string, parentRunId?: string, tags?: string[], metadata?: KVMap, name?: string): Promise<Run$1>;
	handleToolEnd(output: any, runId: string): Promise<Run$1>;
	handleToolError(error: unknown, runId: string): Promise<Run$1>;
	handleAgentAction(action: AgentAction, runId: string): Promise<void>;
	handleAgentEnd(action: AgentFinish, runId: string): Promise<void>;
	/**
	 * Create and add a run to the run map for retriever start events.
	 * This must sometimes be done synchronously to avoid race conditions
	 * when callbacks are backgrounded, so we expose it as a separate method here.
	 */
	_createRunForRetrieverStart(retriever: Serialized, query: string, runId: string, parentRunId?: string, tags?: string[], metadata?: KVMap, name?: string): {
		id: string;
		start_time: number;
		execution_order: number;
		child_runs: Run$1[];
		child_execution_order: number;
		events: {
			name: string;
			time: string;
			kwargs?: Record<string, unknown> | undefined;
		}[];
		trace_id?: string | undefined;
		dotted_order?: string | undefined;
		name: string;
		run_type: string;
		end_time?: number | undefined;
		extra?: KVMap | undefined;
		error?: string | undefined;
		serialized?: object | undefined;
		inputs: KVMap;
		outputs?: KVMap | undefined;
		reference_example_id?: string | undefined;
		parent_run_id?: string | undefined;
		tags?: string[] | undefined;
		attachments?: Attachments | undefined;
	};
	handleRetrieverStart(retriever: Serialized, query: string, runId: string, parentRunId?: string, tags?: string[], metadata?: KVMap, name?: string): Promise<Run$1>;
	handleRetrieverEnd(documents: Document$1<Record<string, unknown>>[], runId: string): Promise<Run$1>;
	handleRetrieverError(error: unknown, runId: string): Promise<Run$1>;
	handleText(text: string, runId: string): Promise<void>;
	handleLLMNewToken(token: string, idx: NewTokenIndices, runId: string, _parentRunId?: string, _tags?: string[], fields?: HandleLLMNewTokenCallbackFields): Promise<Run$1>;
	onRunCreate?(run: Run$1): void | Promise<void>;
	onRunUpdate?(run: Run$1): void | Promise<void>;
	onLLMStart?(run: Run$1): void | Promise<void>;
	onLLMEnd?(run: Run$1): void | Promise<void>;
	onLLMError?(run: Run$1): void | Promise<void>;
	onChainStart?(run: Run$1): void | Promise<void>;
	onChainEnd?(run: Run$1): void | Promise<void>;
	onChainError?(run: Run$1): void | Promise<void>;
	onToolStart?(run: Run$1): void | Promise<void>;
	onToolEnd?(run: Run$1): void | Promise<void>;
	onToolError?(run: Run$1): void | Promise<void>;
	onAgentAction?(run: Run$1): void | Promise<void>;
	onAgentEnd?(run: Run$1): void | Promise<void>;
	onRetrieverStart?(run: Run$1): void | Promise<void>;
	onRetrieverEnd?(run: Run$1): void | Promise<void>;
	onRetrieverError?(run: Run$1): void | Promise<void>;
	onText?(run: Run$1): void | Promise<void>;
	onLLMNewToken?(run: Run$1, token: string, kwargs?: {
		chunk: any;
	}): void | Promise<void>;
}
type BaseCallbackManagerMethods = {
	[K in keyof CallbackHandlerMethods]?: (...args: Parameters<Required<CallbackHandlerMethods>[K]>) => Promise<unknown>;
};
interface CallbackManagerOptions {
	verbose?: boolean;
	tracing?: boolean;
}
type Callbacks = CallbackManager | (BaseCallbackHandler | CallbackHandlerMethods)[];
interface BaseCallbackConfig {
	/**
	 * Name for the tracer run for this call. Defaults to the name of the class.
	 */
	runName?: string;
	/**
	 * Tags for this call and any sub-calls (eg. a Chain calling an LLM).
	 * You can use these to filter calls.
	 */
	tags?: string[];
	/**
	 * Metadata for this call and any sub-calls (eg. a Chain calling an LLM).
	 * Keys should be strings, values should be JSON-serializable.
	 */
	metadata?: Record<string, unknown>;
	/**
	 * Callbacks for this call and any sub-calls (eg. a Chain calling an LLM).
	 * Tags are passed to all callbacks, metadata is passed to handle*Start callbacks.
	 */
	callbacks?: Callbacks;
	/**
	 * Unique identifier for the tracer run for this call. If not provided, a new UUID
	 * will be generated.
	 */
	runId?: string;
}
declare abstract class BaseCallbackManager {
	abstract addHandler(handler: BaseCallbackHandler): void;
	abstract removeHandler(handler: BaseCallbackHandler): void;
	abstract setHandlers(handlers: BaseCallbackHandler[]): void;
	setHandler(handler: BaseCallbackHandler): void;
}
declare class BaseRunManager {
	readonly runId: string;
	readonly handlers: BaseCallbackHandler[];
	protected readonly inheritableHandlers: BaseCallbackHandler[];
	protected readonly tags: string[];
	protected readonly inheritableTags: string[];
	protected readonly metadata: Record<string, unknown>;
	protected readonly inheritableMetadata: Record<string, unknown>;
	protected readonly _parentRunId?: string | undefined;
	constructor(runId: string, handlers: BaseCallbackHandler[], inheritableHandlers: BaseCallbackHandler[], tags: string[], inheritableTags: string[], metadata: Record<string, unknown>, inheritableMetadata: Record<string, unknown>, _parentRunId?: string | undefined);
	get parentRunId(): string | undefined;
	handleText(text: string): Promise<void>;
	handleCustomEvent(eventName: string, data: any, _runId?: string, _tags?: string[], _metadata?: Record<string, any>): Promise<void>;
}
declare class CallbackManagerForRetrieverRun extends BaseRunManager implements BaseCallbackManagerMethods {
	getChild(tag?: string): CallbackManager;
	handleRetrieverEnd(documents: DocumentInterface[]): Promise<void>;
	handleRetrieverError(err: Error | unknown): Promise<void>;
}
declare class CallbackManagerForLLMRun extends BaseRunManager implements BaseCallbackManagerMethods {
	handleLLMNewToken(token: string, idx?: NewTokenIndices, _runId?: string, _parentRunId?: string, _tags?: string[], fields?: HandleLLMNewTokenCallbackFields): Promise<void>;
	handleLLMError(err: Error | unknown, _runId?: string, _parentRunId?: string, _tags?: string[], extraParams?: Record<string, unknown>): Promise<void>;
	handleLLMEnd(output: LLMResult, _runId?: string, _parentRunId?: string, _tags?: string[], extraParams?: Record<string, unknown>): Promise<void>;
}
declare class CallbackManagerForChainRun extends BaseRunManager implements BaseCallbackManagerMethods {
	getChild(tag?: string): CallbackManager;
	handleChainError(err: Error | unknown, _runId?: string, _parentRunId?: string, _tags?: string[], kwargs?: {
		inputs?: Record<string, unknown>;
	}): Promise<void>;
	handleChainEnd(output: ChainValues, _runId?: string, _parentRunId?: string, _tags?: string[], kwargs?: {
		inputs?: Record<string, unknown>;
	}): Promise<void>;
	handleAgentAction(action: AgentAction): Promise<void>;
	handleAgentEnd(action: AgentFinish): Promise<void>;
}
declare class CallbackManagerForToolRun extends BaseRunManager implements BaseCallbackManagerMethods {
	getChild(tag?: string): CallbackManager;
	handleToolError(err: Error | unknown): Promise<void>;
	handleToolEnd(output: any): Promise<void>;
}
declare class CallbackManager extends BaseCallbackManager implements BaseCallbackManagerMethods {
	handlers: BaseCallbackHandler[];
	inheritableHandlers: BaseCallbackHandler[];
	tags: string[];
	inheritableTags: string[];
	metadata: Record<string, unknown>;
	inheritableMetadata: Record<string, unknown>;
	name: string;
	_parentRunId?: string;
	constructor(parentRunId?: string, options?: {
		handlers?: BaseCallbackHandler[];
		inheritableHandlers?: BaseCallbackHandler[];
		tags?: string[];
		inheritableTags?: string[];
		metadata?: Record<string, unknown>;
		inheritableMetadata?: Record<string, unknown>;
	});
	/**
	 * Gets the parent run ID, if any.
	 *
	 * @returns The parent run ID.
	 */
	getParentRunId(): string | undefined;
	handleLLMStart(llm: Serialized, prompts: string[], runId?: string | undefined, _parentRunId?: string | undefined, extraParams?: Record<string, unknown> | undefined, _tags?: string[] | undefined, _metadata?: Record<string, unknown> | undefined, runName?: string | undefined): Promise<CallbackManagerForLLMRun[]>;
	handleChatModelStart(llm: Serialized, messages: BaseMessage[][], runId?: string | undefined, _parentRunId?: string | undefined, extraParams?: Record<string, unknown> | undefined, _tags?: string[] | undefined, _metadata?: Record<string, unknown> | undefined, runName?: string | undefined): Promise<CallbackManagerForLLMRun[]>;
	handleChainStart(chain: Serialized, inputs: ChainValues, runId?: string, runType?: string | undefined, _tags?: string[] | undefined, _metadata?: Record<string, unknown> | undefined, runName?: string | undefined): Promise<CallbackManagerForChainRun>;
	handleToolStart(tool: Serialized, input: string, runId?: string, _parentRunId?: string | undefined, _tags?: string[] | undefined, _metadata?: Record<string, unknown> | undefined, runName?: string | undefined): Promise<CallbackManagerForToolRun>;
	handleRetrieverStart(retriever: Serialized, query: string, runId?: string, _parentRunId?: string | undefined, _tags?: string[] | undefined, _metadata?: Record<string, unknown> | undefined, runName?: string | undefined): Promise<CallbackManagerForRetrieverRun>;
	handleCustomEvent?(eventName: string, data: any, runId: string, _tags?: string[], _metadata?: Record<string, any>): Promise<any>;
	addHandler(handler: BaseCallbackHandler, inherit?: boolean): void;
	removeHandler(handler: BaseCallbackHandler): void;
	setHandlers(handlers: BaseCallbackHandler[], inherit?: boolean): void;
	addTags(tags: string[], inherit?: boolean): void;
	removeTags(tags: string[]): void;
	addMetadata(metadata: Record<string, unknown>, inherit?: boolean): void;
	removeMetadata(metadata: Record<string, unknown>): void;
	copy(additionalHandlers?: BaseCallbackHandler[], inherit?: boolean): CallbackManager;
	static fromHandlers(handlers: CallbackHandlerMethods): CallbackManager;
	static configure(inheritableHandlers?: Callbacks, localHandlers?: Callbacks, inheritableTags?: string[], localTags?: string[], inheritableMetadata?: Record<string, unknown>, localMetadata?: Record<string, unknown>, options?: CallbackManagerOptions): CallbackManager | undefined;
	static _configureSync(inheritableHandlers?: Callbacks, localHandlers?: Callbacks, inheritableTags?: string[], localTags?: string[], inheritableMetadata?: Record<string, unknown>, localMetadata?: Record<string, unknown>, options?: CallbackManagerOptions): CallbackManager | undefined;
}
type FailedAttemptHandler = (error: any) => any;
interface AsyncCallerParams$1 {
	/**
	 * The maximum number of concurrent calls that can be made.
	 * Defaults to `Infinity`, which means no limit.
	 */
	maxConcurrency?: number;
	/**
	 * The maximum number of retries that can be made for a single call,
	 * with an exponential backoff between each attempt. Defaults to 6.
	 */
	maxRetries?: number;
	/**
	 * Custom handler to handle failed attempts. Takes the originally thrown
	 * error object as input, and should itself throw an error if the input
	 * error is not retryable.
	 */
	onFailedAttempt?: FailedAttemptHandler;
}
interface AsyncCallerCallOptions {
	signal?: AbortSignal;
}
declare class AsyncCaller {
	protected maxConcurrency: AsyncCallerParams$1["maxConcurrency"];
	protected maxRetries: AsyncCallerParams$1["maxRetries"];
	protected onFailedAttempt: AsyncCallerParams$1["onFailedAttempt"];
	private queue;
	constructor(params: AsyncCallerParams$1);
	call<A extends any[], T extends (...args: A) => Promise<any>>(callable: T, ...args: Parameters<T>): Promise<Awaited<ReturnType<T>>>;
	callWithOptions<A extends any[], T extends (...args: A) => Promise<any>>(options: AsyncCallerCallOptions, callable: T, ...args: Parameters<T>): Promise<Awaited<ReturnType<T>>>;
	fetch(...args: Parameters<typeof fetch>): ReturnType<typeof fetch>;
}
type IterableReadableStreamInterface<T> = ReadableStream<T> & AsyncIterable<T>;
type RunnableBatchOptions = {
	/** @deprecated Pass in via the standard runnable config object instead */
	maxConcurrency?: number;
	returnExceptions?: boolean;
};
type RunnableIOSchema = {
	name?: string;
	schema: z.ZodType;
};
interface RunnableInterface<RunInput = any, RunOutput = any, CallOptions extends RunnableConfig = RunnableConfig> extends SerializableInterface {
	lc_serializable: boolean;
	invoke(input: RunInput, options?: Partial<CallOptions>): Promise<RunOutput>;
	batch(inputs: RunInput[], options?: Partial<CallOptions> | Partial<CallOptions>[], batchOptions?: RunnableBatchOptions & {
		returnExceptions?: false;
	}): Promise<RunOutput[]>;
	batch(inputs: RunInput[], options?: Partial<CallOptions> | Partial<CallOptions>[], batchOptions?: RunnableBatchOptions & {
		returnExceptions: true;
	}): Promise<(RunOutput | Error)[]>;
	batch(inputs: RunInput[], options?: Partial<CallOptions> | Partial<CallOptions>[], batchOptions?: RunnableBatchOptions): Promise<(RunOutput | Error)[]>;
	stream(input: RunInput, options?: Partial<CallOptions>): Promise<IterableReadableStreamInterface<RunOutput>>;
	transform(generator: AsyncGenerator<RunInput>, options: Partial<CallOptions>): AsyncGenerator<RunOutput>;
	getName(suffix?: string): string;
}
interface Edge {
	source: string;
	target: string;
	data?: string;
	conditional?: boolean;
}
interface Node$1 {
	id: string;
	name: string;
	data: RunnableIOSchema | RunnableInterface;
	metadata?: Record<string, any>;
}
interface RunnableConfig<ConfigurableFieldType extends Record<string, any> = Record<string, any>> extends BaseCallbackConfig {
	/**
	 * Runtime values for attributes previously made configurable on this Runnable,
	 * or sub-Runnables.
	 */
	configurable?: ConfigurableFieldType;
	/**
	 * Maximum number of times a call can recurse. If not provided, defaults to 25.
	 */
	recursionLimit?: number;
	/** Maximum number of parallel calls to make. */
	maxConcurrency?: number;
	/**
	 * Timeout for this call in milliseconds.
	 */
	timeout?: number;
	/**
	 * Abort signal for this call.
	 * If provided, the call will be aborted when the signal is aborted.
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal
	 */
	signal?: AbortSignal;
}
type Operation = AddOperation<any> | RemoveOperation | ReplaceOperation<any> | MoveOperation | CopyOperation | TestOperation<any> | GetOperation<any>;
interface BaseOperation {
	path: string;
}
interface AddOperation<T> extends BaseOperation {
	op: "add";
	value: T;
}
interface RemoveOperation extends BaseOperation {
	op: "remove";
}
interface ReplaceOperation<T> extends BaseOperation {
	op: "replace";
	value: T;
}
interface MoveOperation extends BaseOperation {
	op: "move";
	from: string;
}
interface CopyOperation extends BaseOperation {
	op: "copy";
	from: string;
}
interface TestOperation<T> extends BaseOperation {
	op: "test";
	value: T;
}
interface GetOperation<T> extends BaseOperation {
	op: "_get";
	value: T;
}
declare class IterableReadableStream<T> extends ReadableStream<T> implements IterableReadableStreamInterface<T> {
	reader: ReadableStreamDefaultReader<T>;
	ensureReader(): void;
	next(): Promise<IteratorResult<T>>;
	return(): Promise<IteratorResult<T>>;
	throw(e: any): Promise<IteratorResult<T>>;
	[Symbol.asyncIterator](): this;
	[Symbol.asyncDispose](): Promise<void>;
	static fromReadableStream<T>(stream: ReadableStream<T>): IterableReadableStream<T>;
	static fromAsyncGenerator<T>(generator: AsyncGenerator<T>): IterableReadableStream<T>;
}
type StreamEventData = {
	/**
	 * The input passed to the runnable that generated the event.
	 * Inputs will sometimes be available at the *START* of the runnable, and
	 * sometimes at the *END* of the runnable.
	 * If a runnable is able to stream its inputs, then its input by definition
	 * won't be known until the *END* of the runnable when it has finished streaming
	 * its inputs.
	 */
	input?: any;
	/**
	 * The output of the runnable that generated the event.
	 * Outputs will only be available at the *END* of the runnable.
	 * For most runnables, this field can be inferred from the `chunk` field,
	 * though there might be some exceptions for special cased runnables (e.g., like
	 * chat models), which may return more information.
	 */
	output?: any;
	/**
	 * A streaming chunk from the output that generated the event.
	 * chunks support addition in general, and adding them up should result
	 * in the output of the runnable that generated the event.
	 */
	chunk?: any;
};
type StreamEvent = {
	/**
	 * Event names are of the format: on_[runnable_type]_(start|stream|end).
	 *
	 * Runnable types are one of:
	 * - llm - used by non chat models
	 * - chat_model - used by chat models
	 * - prompt --  e.g., ChatPromptTemplate
	 * - tool -- LangChain tools
	 * - chain - most Runnables are of this type
	 *
	 * Further, the events are categorized as one of:
	 * - start - when the runnable starts
	 * - stream - when the runnable is streaming
	 * - end - when the runnable ends
	 *
	 * start, stream and end are associated with slightly different `data` payload.
	 *
	 * Please see the documentation for `EventData` for more details.
	 */
	event: string;
	/** The name of the runnable that generated the event. */
	name: string;
	/**
	 * An randomly generated ID to keep track of the execution of the given runnable.
	 *
	 * Each child runnable that gets invoked as part of the execution of a parent runnable
	 * is assigned its own unique ID.
	 */
	run_id: string;
	/**
	 * Tags associated with the runnable that generated this event.
	 * Tags are always inherited from parent runnables.
	 */
	tags?: string[];
	/** Metadata associated with the runnable that generated this event. */
	metadata: Record<string, any>;
	/**
	 * Event data.
	 *
	 * The contents of the event data depend on the event type.
	 */
	data: StreamEventData;
};
interface EventStreamCallbackHandlerInput extends BaseCallbackHandlerInput {
	autoClose?: boolean;
	includeNames?: string[];
	includeTypes?: string[];
	includeTags?: string[];
	excludeNames?: string[];
	excludeTypes?: string[];
	excludeTags?: string[];
}
type LogEntry = {
	/** ID of the sub-run. */
	id: string;
	/** Name of the object being run. */
	name: string;
	/** Type of the object being run, eg. prompt, chain, llm, etc. */
	type: string;
	/** List of tags for the run. */
	tags: string[];
	/** Key-value pairs of metadata for the run. */
	metadata: Record<string, any>;
	/** ISO-8601 timestamp of when the run started. */
	start_time: string;
	/** List of general output chunks streamed by this run. */
	streamed_output: any[];
	/** List of LLM tokens streamed by this run, if applicable. */
	streamed_output_str: string[];
	/** Inputs to this run. Not available currently via streamLog. */
	inputs?: any;
	/** Final output of this run. Only available after the run has finished successfully. */
	final_output?: any;
	/** ISO-8601 timestamp of when the run ended. Only available after the run has finished. */
	end_time?: string;
};
type RunState = {
	/** ID of the sub-run. */
	id: string;
	/** List of output chunks streamed by Runnable.stream() */
	streamed_output: any[];
	/** Final output of the run, usually the result of aggregating streamed_output. Only available after the run has finished successfully. */
	final_output?: any;
	/**
	 * List of sub-runs contained in this run, if any, in the order they were started.
	 * If filters were supplied, this list will contain only the runs that matched the filters.
	 */
	logs: Record<string, LogEntry>;
	/** Name of the object being run. */
	name: string;
	/** Type of the object being run, eg. prompt, chain, llm, etc. */
	type: string;
};
declare class RunLogPatch {
	ops: Operation[];
	constructor(fields: {
		ops?: Operation[];
	});
	concat(other: RunLogPatch): RunLog;
}
declare class RunLog extends RunLogPatch {
	state: RunState;
	constructor(fields: {
		ops?: Operation[];
		state: RunState;
	});
	concat(other: RunLogPatch): RunLog;
	static fromRunLogPatch(patch: RunLogPatch): RunLog;
}
type SchemaFormat = "original" | "streaming_events";
interface LogStreamCallbackHandlerInput extends BaseCallbackHandlerInput {
	autoClose?: boolean;
	includeNames?: string[];
	includeTypes?: string[];
	includeTags?: string[];
	excludeNames?: string[];
	excludeTypes?: string[];
	excludeTags?: string[];
	_schemaFormat?: SchemaFormat;
}
declare class LogStreamCallbackHandler extends BaseTracer implements CallbackHandlerPrefersStreaming {
	protected autoClose: boolean;
	protected includeNames?: string[];
	protected includeTypes?: string[];
	protected includeTags?: string[];
	protected excludeNames?: string[];
	protected excludeTypes?: string[];
	protected excludeTags?: string[];
	protected _schemaFormat: SchemaFormat;
	protected rootId?: string;
	private keyMapByRunId;
	private counterMapByRunName;
	protected transformStream: TransformStream;
	writer: WritableStreamDefaultWriter;
	receiveStream: IterableReadableStream<RunLogPatch>;
	name: string;
	lc_prefer_streaming: boolean;
	constructor(fields?: LogStreamCallbackHandlerInput);
	[Symbol.asyncIterator](): IterableReadableStream<RunLogPatch>;
	protected persistRun(_run: Run$1): Promise<void>;
	_includeRun(run: Run$1): boolean;
	tapOutputIterable<T>(runId: string, output: AsyncGenerator<T>): AsyncGenerator<T>;
	onRunCreate(run: Run$1): Promise<void>;
	onRunUpdate(run: Run$1): Promise<void>;
	onLLMNewToken(run: Run$1, token: string, kwargs?: HandleLLMNewTokenCallbackFields): Promise<void>;
}
declare class Graph {
	nodes: Record<string, Node$1>;
	edges: Edge[];
	constructor(params?: {
		nodes: Record<string, Node$1>;
		edges: Edge[];
	});
	toJSON(): Record<string, any>;
	addNode(data: RunnableInterface | RunnableIOSchema, id?: string, metadata?: Record<string, any>): Node$1;
	removeNode(node: Node$1): void;
	addEdge(source: Node$1, target: Node$1, data?: string, conditional?: boolean): Edge;
	firstNode(): Node$1 | undefined;
	lastNode(): Node$1 | undefined;
	/**
	 * Add all nodes and edges from another graph.
	 * Note this doesn't check for duplicates, nor does it connect the graphs.
	 */
	extend(graph: Graph, prefix?: string): ({
		id: string;
		data: RunnableIOSchema | RunnableInterface<any, any, RunnableConfig<Record<string, any>>>;
	} | undefined)[];
	trimFirstNode(): void;
	trimLastNode(): void;
	/**
	 * Return a new graph with all nodes re-identified,
	 * using their unique, readable names where possible.
	 */
	reid(): Graph;
	drawMermaid(params?: {
		withStyles?: boolean;
		curveStyle?: string;
		nodeColors?: Record<string, string>;
		wrapLabelNWords?: number;
	}): string;
	drawMermaidPng(params?: {
		withStyles?: boolean;
		curveStyle?: string;
		nodeColors?: Record<string, string>;
		wrapLabelNWords?: number;
		backgroundColor?: string;
	}): Promise<Blob>;
}
type RunnableFunc<RunInput, RunOutput, CallOptions extends RunnableConfig = RunnableConfig> = (input: RunInput, options: CallOptions | Record<string, any> | (Record<string, any> & CallOptions)) => RunOutput | Promise<RunOutput>;
type RunnableMapLike<RunInput, RunOutput> = {
	[K in keyof RunOutput]: RunnableLike<RunInput, RunOutput[K]>;
};
type RunnableLike<RunInput = any, RunOutput = any, CallOptions extends RunnableConfig = RunnableConfig> = RunnableInterface<RunInput, RunOutput, CallOptions> | RunnableFunc<RunInput, RunOutput, CallOptions> | RunnableMapLike<RunInput, RunOutput>;
type RunnableRetryFailedAttemptHandler = (error: any, input: any) => any;
declare abstract class Runnable<RunInput = any, RunOutput = any, CallOptions extends RunnableConfig = RunnableConfig> extends Serializable implements RunnableInterface<RunInput, RunOutput, CallOptions> {
	protected lc_runnable: boolean;
	name?: string;
	getName(suffix?: string): string;
	abstract invoke(input: RunInput, options?: Partial<CallOptions>): Promise<RunOutput>;
	/**
	 * Bind arguments to a Runnable, returning a new Runnable.
	 * @param kwargs
	 * @returns A new RunnableBinding that, when invoked, will apply the bound args.
	 */
	bind(kwargs: Partial<CallOptions>): Runnable<RunInput, RunOutput, CallOptions>;
	/**
	 * Return a new Runnable that maps a list of inputs to a list of outputs,
	 * by calling invoke() with each input.
	 */
	map(): Runnable<RunInput[], RunOutput[], CallOptions>;
	/**
	 * Add retry logic to an existing runnable.
	 * @param kwargs
	 * @returns A new RunnableRetry that, when invoked, will retry according to the parameters.
	 */
	withRetry(fields?: {
		stopAfterAttempt?: number;
		onFailedAttempt?: RunnableRetryFailedAttemptHandler;
	}): RunnableRetry<RunInput, RunOutput, CallOptions>;
	/**
	 * Bind config to a Runnable, returning a new Runnable.
	 * @param config New configuration parameters to attach to the new runnable.
	 * @returns A new RunnableBinding with a config matching what's passed.
	 */
	withConfig(config: RunnableConfig): Runnable<RunInput, RunOutput, CallOptions>;
	/**
	 * Create a new runnable from the current one that will try invoking
	 * other passed fallback runnables if the initial invocation fails.
	 * @param fields.fallbacks Other runnables to call if the runnable errors.
	 * @returns A new RunnableWithFallbacks.
	 */
	withFallbacks(fields: {
		fallbacks: Runnable<RunInput, RunOutput>[];
	} | Runnable<RunInput, RunOutput>[]): RunnableWithFallbacks<RunInput, RunOutput>;
	protected _getOptionsList<O extends CallOptions & {
		runType?: string;
	}>(options: Partial<O> | Partial<O>[], length?: number): Partial<O>[];
	/**
	 * Default implementation of batch, which calls invoke N times.
	 * Subclasses should override this method if they can batch more efficiently.
	 * @param inputs Array of inputs to each batch call.
	 * @param options Either a single call options object to apply to each batch call or an array for each call.
	 * @param batchOptions.returnExceptions Whether to return errors rather than throwing on the first one
	 * @returns An array of RunOutputs, or mixed RunOutputs and errors if batchOptions.returnExceptions is set
	 */
	batch(inputs: RunInput[], options?: Partial<CallOptions> | Partial<CallOptions>[], batchOptions?: RunnableBatchOptions & {
		returnExceptions?: false;
	}): Promise<RunOutput[]>;
	batch(inputs: RunInput[], options?: Partial<CallOptions> | Partial<CallOptions>[], batchOptions?: RunnableBatchOptions & {
		returnExceptions: true;
	}): Promise<(RunOutput | Error)[]>;
	batch(inputs: RunInput[], options?: Partial<CallOptions> | Partial<CallOptions>[], batchOptions?: RunnableBatchOptions): Promise<(RunOutput | Error)[]>;
	/**
	 * Default streaming implementation.
	 * Subclasses should override this method if they support streaming output.
	 * @param input
	 * @param options
	 */
	_streamIterator(input: RunInput, options?: Partial<CallOptions>): AsyncGenerator<RunOutput>;
	/**
	 * Stream output in chunks.
	 * @param input
	 * @param options
	 * @returns A readable stream that is also an iterable.
	 */
	stream(input: RunInput, options?: Partial<CallOptions>): Promise<IterableReadableStream<RunOutput>>;
	protected _separateRunnableConfigFromCallOptions(options?: Partial<CallOptions>): [
		RunnableConfig,
		Omit<Partial<CallOptions>, keyof RunnableConfig>
	];
	protected _callWithConfig<T extends RunInput>(func: ((input: T) => Promise<RunOutput>) | ((input: T, config?: Partial<CallOptions>, runManager?: CallbackManagerForChainRun) => Promise<RunOutput>), input: T, options?: Partial<CallOptions> & {
		runType?: string;
	}): Promise<RunOutput>;
	/**
	 * Internal method that handles batching and configuration for a runnable
	 * It takes a function, input values, and optional configuration, and
	 * returns a promise that resolves to the output values.
	 * @param func The function to be executed for each input value.
	 * @param input The input values to be processed.
	 * @param config Optional configuration for the function execution.
	 * @returns A promise that resolves to the output values.
	 */
	_batchWithConfig<T extends RunInput>(func: (inputs: T[], options?: Partial<CallOptions>[], runManagers?: (CallbackManagerForChainRun | undefined)[], batchOptions?: RunnableBatchOptions) => Promise<(RunOutput | Error)[]>, inputs: T[], options?: Partial<CallOptions & {
		runType?: string;
	}> | Partial<CallOptions & {
		runType?: string;
	}>[], batchOptions?: RunnableBatchOptions): Promise<(RunOutput | Error)[]>;
	/**
	 * Helper method to transform an Iterator of Input values into an Iterator of
	 * Output values, with callbacks.
	 * Use this to implement `stream()` or `transform()` in Runnable subclasses.
	 */
	protected _transformStreamWithConfig<I extends RunInput, O extends RunOutput>(inputGenerator: AsyncGenerator<I>, transformer: (generator: AsyncGenerator<I>, runManager?: CallbackManagerForChainRun, options?: Partial<CallOptions>) => AsyncGenerator<O>, options?: Partial<CallOptions> & {
		runType?: string;
	}): AsyncGenerator<O>;
	getGraph(_?: RunnableConfig): Graph;
	/**
	 * Create a new runnable sequence that runs each individual runnable in series,
	 * piping the output of one runnable into another runnable or runnable-like.
	 * @param coerceable A runnable, function, or object whose values are functions or runnables.
	 * @returns A new runnable sequence.
	 */
	pipe<NewRunOutput>(coerceable: RunnableLike<RunOutput, NewRunOutput>): Runnable<RunInput, Exclude<NewRunOutput, Error>>;
	/**
	 * Pick keys from the dict output of this runnable. Returns a new runnable.
	 */
	pick(keys: string | string[]): Runnable;
	/**
	 * Assigns new fields to the dict output of this runnable. Returns a new runnable.
	 */
	assign(mapping: RunnableMapLike<Record<string, unknown>, Record<string, unknown>>): Runnable;
	/**
	 * Default implementation of transform, which buffers input and then calls stream.
	 * Subclasses should override this method if they can start producing output while
	 * input is still being generated.
	 * @param generator
	 * @param options
	 */
	transform(generator: AsyncGenerator<RunInput>, options: Partial<CallOptions>): AsyncGenerator<RunOutput>;
	/**
	 * Stream all output from a runnable, as reported to the callback system.
	 * This includes all inner runs of LLMs, Retrievers, Tools, etc.
	 * Output is streamed as Log objects, which include a list of
	 * jsonpatch ops that describe how the state of the run has changed in each
	 * step, and the final state of the run.
	 * The jsonpatch ops can be applied in order to construct state.
	 * @param input
	 * @param options
	 * @param streamOptions
	 */
	streamLog(input: RunInput, options?: Partial<CallOptions>, streamOptions?: Omit<LogStreamCallbackHandlerInput, "autoClose">): AsyncGenerator<RunLogPatch>;
	protected _streamLog(input: RunInput, logStreamCallbackHandler: LogStreamCallbackHandler, config: Partial<CallOptions>): AsyncGenerator<RunLogPatch>;
	/**
	 * Generate a stream of events emitted by the internal steps of the runnable.
	 *
	 * Use to create an iterator over StreamEvents that provide real-time information
	 * about the progress of the runnable, including StreamEvents from intermediate
	 * results.
	 *
	 * A StreamEvent is a dictionary with the following schema:
	 *
	 * - `event`: string - Event names are of the format: on_[runnable_type]_(start|stream|end).
	 * - `name`: string - The name of the runnable that generated the event.
	 * - `run_id`: string - Randomly generated ID associated with the given execution of
	 *   the runnable that emitted the event. A child runnable that gets invoked as part of the execution of a
	 *   parent runnable is assigned its own unique ID.
	 * - `tags`: string[] - The tags of the runnable that generated the event.
	 * - `metadata`: Record<string, any> - The metadata of the runnable that generated the event.
	 * - `data`: Record<string, any>
	 *
	 * Below is a table that illustrates some events that might be emitted by various
	 * chains. Metadata fields have been omitted from the table for brevity.
	 * Chain definitions have been included after the table.
	 *
	 * **ATTENTION** This reference table is for the V2 version of the schema.
	 *
	 * ```md
	 * +----------------------+-----------------------------+------------------------------------------+
	 * | event                | input                       | output/chunk                             |
	 * +======================+=============================+==========================================+
	 * | on_chat_model_start  | {"messages": BaseMessage[]} |                                          |
	 * +----------------------+-----------------------------+------------------------------------------+
	 * | on_chat_model_stream |                             | AIMessageChunk("hello")                  |
	 * +----------------------+-----------------------------+------------------------------------------+
	 * | on_chat_model_end    | {"messages": BaseMessage[]} | AIMessageChunk("hello world")            |
	 * +----------------------+-----------------------------+------------------------------------------+
	 * | on_llm_start         | {'input': 'hello'}          |                                          |
	 * +----------------------+-----------------------------+------------------------------------------+
	 * | on_llm_stream        |                             | 'Hello'                                  |
	 * +----------------------+-----------------------------+------------------------------------------+
	 * | on_llm_end           | 'Hello human!'              |                                          |
	 * +----------------------+-----------------------------+------------------------------------------+
	 * | on_chain_start       |                             |                                          |
	 * +----------------------+-----------------------------+------------------------------------------+
	 * | on_chain_stream      |                             | "hello world!"                           |
	 * +----------------------+-----------------------------+------------------------------------------+
	 * | on_chain_end         | [Document(...)]             | "hello world!, goodbye world!"           |
	 * +----------------------+-----------------------------+------------------------------------------+
	 * | on_tool_start        | {"x": 1, "y": "2"}          |                                          |
	 * +----------------------+-----------------------------+------------------------------------------+
	 * | on_tool_end          |                             | {"x": 1, "y": "2"}                       |
	 * +----------------------+-----------------------------+------------------------------------------+
	 * | on_retriever_start   | {"query": "hello"}          |                                          |
	 * +----------------------+-----------------------------+------------------------------------------+
	 * | on_retriever_end     | {"query": "hello"}          | [Document(...), ..]                      |
	 * +----------------------+-----------------------------+------------------------------------------+
	 * | on_prompt_start      | {"question": "hello"}       |                                          |
	 * +----------------------+-----------------------------+------------------------------------------+
	 * | on_prompt_end        | {"question": "hello"}       | ChatPromptValue(messages: BaseMessage[]) |
	 * +----------------------+-----------------------------+------------------------------------------+
	 * ```
	 *
	 * The "on_chain_*" events are the default for Runnables that don't fit one of the above categories.
	 *
	 * In addition to the standard events above, users can also dispatch custom events.
	 *
	 * Custom events will be only be surfaced with in the `v2` version of the API!
	 *
	 * A custom event has following format:
	 *
	 * ```md
	 * +-----------+------+------------------------------------------------------------+
	 * | Attribute | Type | Description                                                |
	 * +===========+======+============================================================+
	 * | name      | str  | A user defined name for the event.                         |
	 * +-----------+------+------------------------------------------------------------+
	 * | data      | Any  | The data associated with the event. This can be anything.  |
	 * +-----------+------+------------------------------------------------------------+
	 * ```
	 *
	 * Here's an example:
	 *
	 * ```ts
	 * import { RunnableLambda } from "@langchain/core/runnables";
	 * import { dispatchCustomEvent } from "@langchain/core/callbacks/dispatch";
	 * // Use this import for web environments that don't support "async_hooks"
	 * // and manually pass config to child runs.
	 * // import { dispatchCustomEvent } from "@langchain/core/callbacks/dispatch/web";
	 *
	 * const slowThing = RunnableLambda.from(async (someInput: string) => {
	 *   // Placeholder for some slow operation
	 *   await new Promise((resolve) => setTimeout(resolve, 100));
	 *   await dispatchCustomEvent("progress_event", {
	 *    message: "Finished step 1 of 2",
	 *  });
	 *  await new Promise((resolve) => setTimeout(resolve, 100));
	 *  return "Done";
	 * });
	 *
	 * const eventStream = await slowThing.streamEvents("hello world", {
	 *   version: "v2",
	 * });
	 *
	 * for await (const event of eventStream) {
	 *  if (event.event === "on_custom_event") {
	 *    console.log(event);
	 *  }
	 * }
	 * ```
	 */
	streamEvents(input: RunInput, options: Partial<CallOptions> & {
		version: "v1" | "v2";
	}, streamOptions?: Omit<EventStreamCallbackHandlerInput, "autoClose">): IterableReadableStream<StreamEvent>;
	streamEvents(input: RunInput, options: Partial<CallOptions> & {
		version: "v1" | "v2";
		encoding: "text/event-stream";
	}, streamOptions?: Omit<EventStreamCallbackHandlerInput, "autoClose">): IterableReadableStream<Uint8Array>;
	private _streamEventsV2;
	private _streamEventsV1;
	static isRunnable(thing: any): thing is Runnable;
	/**
	 * Bind lifecycle listeners to a Runnable, returning a new Runnable.
	 * The Run object contains information about the run, including its id,
	 * type, input, output, error, startTime, endTime, and any tags or metadata
	 * added to the run.
	 *
	 * @param {Object} params - The object containing the callback functions.
	 * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.
	 * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.
	 * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.
	 */
	withListeners({ onStart, onEnd, onError, }: {
		onStart?: (run: Run$1, config?: RunnableConfig) => void | Promise<void>;
		onEnd?: (run: Run$1, config?: RunnableConfig) => void | Promise<void>;
		onError?: (run: Run$1, config?: RunnableConfig) => void | Promise<void>;
	}): Runnable<RunInput, RunOutput, CallOptions>;
	/**
	 * Convert a runnable to a tool. Return a new instance of `RunnableToolLike`
	 * which contains the runnable, name, description and schema.
	 *
	 * @template {T extends RunInput = RunInput} RunInput - The input type of the runnable. Should be the same as the `RunInput` type of the runnable.
	 *
	 * @param fields
	 * @param {string | undefined} [fields.name] The name of the tool. If not provided, it will default to the name of the runnable.
	 * @param {string | undefined} [fields.description] The description of the tool. Falls back to the description on the Zod schema if not provided, or undefined if neither are provided.
	 * @param {z.ZodType<T>} [fields.schema] The Zod schema for the input of the tool. Infers the Zod type from the input type of the runnable.
	 * @returns {RunnableToolLike<z.ZodType<T>, RunOutput>} An instance of `RunnableToolLike` which is a runnable that can be used as a tool.
	 */
	asTool<T extends RunInput = RunInput>(fields: {
		name?: string;
		description?: string;
		schema: z.ZodType<T>;
	}): RunnableToolLike<z.ZodType<T | ToolCall>, RunOutput>;
}
type RunnableBindingArgs<RunInput, RunOutput, CallOptions extends RunnableConfig = RunnableConfig> = {
	bound: Runnable<RunInput, RunOutput, CallOptions>;
	kwargs?: Partial<CallOptions>;
	config: RunnableConfig;
	configFactories?: Array<(config: RunnableConfig) => RunnableConfig>;
};
declare class RunnableBinding<RunInput, RunOutput, CallOptions extends RunnableConfig = RunnableConfig> extends Runnable<RunInput, RunOutput, CallOptions> {
	static lc_name(): string;
	lc_namespace: string[];
	lc_serializable: boolean;
	bound: Runnable<RunInput, RunOutput, CallOptions>;
	config: RunnableConfig;
	kwargs?: Partial<CallOptions>;
	configFactories?: Array<(config: RunnableConfig) => RunnableConfig | Promise<RunnableConfig>>;
	constructor(fields: RunnableBindingArgs<RunInput, RunOutput, CallOptions>);
	getName(suffix?: string | undefined): string;
	_mergeConfig(...options: (Partial<CallOptions> | RunnableConfig | undefined)[]): Promise<Partial<CallOptions>>;
	bind(kwargs: Partial<CallOptions>): RunnableBinding<RunInput, RunOutput, CallOptions>;
	withConfig(config: RunnableConfig): Runnable<RunInput, RunOutput, CallOptions>;
	withRetry(fields?: {
		stopAfterAttempt?: number;
		onFailedAttempt?: RunnableRetryFailedAttemptHandler;
	}): RunnableRetry<RunInput, RunOutput, CallOptions>;
	invoke(input: RunInput, options?: Partial<CallOptions>): Promise<RunOutput>;
	batch(inputs: RunInput[], options?: Partial<CallOptions> | Partial<CallOptions>[], batchOptions?: RunnableBatchOptions & {
		returnExceptions?: false;
	}): Promise<RunOutput[]>;
	batch(inputs: RunInput[], options?: Partial<CallOptions> | Partial<CallOptions>[], batchOptions?: RunnableBatchOptions & {
		returnExceptions: true;
	}): Promise<(RunOutput | Error)[]>;
	batch(inputs: RunInput[], options?: Partial<CallOptions> | Partial<CallOptions>[], batchOptions?: RunnableBatchOptions): Promise<(RunOutput | Error)[]>;
	_streamIterator(input: RunInput, options?: Partial<CallOptions> | undefined): AsyncGenerator<Awaited<RunOutput>, void, unknown>;
	stream(input: RunInput, options?: Partial<CallOptions> | undefined): Promise<IterableReadableStream<RunOutput>>;
	transform(generator: AsyncGenerator<RunInput>, options?: Partial<CallOptions>): AsyncGenerator<RunOutput>;
	streamEvents(input: RunInput, options: Partial<CallOptions> & {
		version: "v1" | "v2";
	}, streamOptions?: Omit<LogStreamCallbackHandlerInput, "autoClose">): IterableReadableStream<StreamEvent>;
	streamEvents(input: RunInput, options: Partial<CallOptions> & {
		version: "v1" | "v2";
		encoding: "text/event-stream";
	}, streamOptions?: Omit<LogStreamCallbackHandlerInput, "autoClose">): IterableReadableStream<Uint8Array>;
	static isRunnableBinding(thing: any): thing is RunnableBinding<any, any, any>;
	/**
	 * Bind lifecycle listeners to a Runnable, returning a new Runnable.
	 * The Run object contains information about the run, including its id,
	 * type, input, output, error, startTime, endTime, and any tags or metadata
	 * added to the run.
	 *
	 * @param {Object} params - The object containing the callback functions.
	 * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.
	 * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.
	 * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.
	 */
	withListeners({ onStart, onEnd, onError, }: {
		onStart?: (run: Run$1, config?: RunnableConfig) => void | Promise<void>;
		onEnd?: (run: Run$1, config?: RunnableConfig) => void | Promise<void>;
		onError?: (run: Run$1, config?: RunnableConfig) => void | Promise<void>;
	}): Runnable<RunInput, RunOutput, CallOptions>;
}
declare class RunnableRetry<RunInput = any, RunOutput = any, CallOptions extends RunnableConfig = RunnableConfig> extends RunnableBinding<RunInput, RunOutput, CallOptions> {
	static lc_name(): string;
	lc_namespace: string[];
	protected maxAttemptNumber: number;
	onFailedAttempt: RunnableRetryFailedAttemptHandler;
	constructor(fields: RunnableBindingArgs<RunInput, RunOutput, CallOptions> & {
		maxAttemptNumber?: number;
		onFailedAttempt?: RunnableRetryFailedAttemptHandler;
	});
	_patchConfigForRetry(attempt: number, config?: Partial<CallOptions>, runManager?: CallbackManagerForChainRun): Partial<CallOptions>;
	protected _invoke(input: RunInput, config?: CallOptions, runManager?: CallbackManagerForChainRun): Promise<RunOutput>;
	/**
	 * Method that invokes the runnable with the specified input, run manager,
	 * and config. It handles the retry logic by catching any errors and
	 * recursively invoking itself with the updated config for the next retry
	 * attempt.
	 * @param input The input for the runnable.
	 * @param runManager The run manager for the runnable.
	 * @param config The config for the runnable.
	 * @returns A promise that resolves to the output of the runnable.
	 */
	invoke(input: RunInput, config?: CallOptions): Promise<RunOutput>;
	_batch<ReturnExceptions extends boolean = false>(inputs: RunInput[], configs?: RunnableConfig[], runManagers?: (CallbackManagerForChainRun | undefined)[], batchOptions?: RunnableBatchOptions): Promise<ReturnExceptions extends false ? RunOutput[] : (Error | RunOutput)[]>;
	batch(inputs: RunInput[], options?: Partial<CallOptions> | Partial<CallOptions>[], batchOptions?: RunnableBatchOptions & {
		returnExceptions?: false;
	}): Promise<RunOutput[]>;
	batch(inputs: RunInput[], options?: Partial<CallOptions> | Partial<CallOptions>[], batchOptions?: RunnableBatchOptions & {
		returnExceptions: true;
	}): Promise<(RunOutput | Error)[]>;
	batch(inputs: RunInput[], options?: Partial<CallOptions> | Partial<CallOptions>[], batchOptions?: RunnableBatchOptions): Promise<(RunOutput | Error)[]>;
}
declare class RunnableWithFallbacks<RunInput, RunOutput> extends Runnable<RunInput, RunOutput> {
	static lc_name(): string;
	lc_namespace: string[];
	lc_serializable: boolean;
	runnable: Runnable<RunInput, RunOutput>;
	fallbacks: Runnable<RunInput, RunOutput>[];
	constructor(fields: {
		runnable: Runnable<RunInput, RunOutput>;
		fallbacks: Runnable<RunInput, RunOutput>[];
	});
	runnables(): Generator<Runnable<RunInput, RunOutput, RunnableConfig<Record<string, any>>>, void, unknown>;
	invoke(input: RunInput, options?: Partial<RunnableConfig>): Promise<RunOutput>;
	_streamIterator(input: RunInput, options?: Partial<RunnableConfig> | undefined): AsyncGenerator<RunOutput>;
	batch(inputs: RunInput[], options?: Partial<RunnableConfig> | Partial<RunnableConfig>[], batchOptions?: RunnableBatchOptions & {
		returnExceptions?: false;
	}): Promise<RunOutput[]>;
	batch(inputs: RunInput[], options?: Partial<RunnableConfig> | Partial<RunnableConfig>[], batchOptions?: RunnableBatchOptions & {
		returnExceptions: true;
	}): Promise<(RunOutput | Error)[]>;
	batch(inputs: RunInput[], options?: Partial<RunnableConfig> | Partial<RunnableConfig>[], batchOptions?: RunnableBatchOptions): Promise<(RunOutput | Error)[]>;
}
interface RunnableToolLikeArgs<RunInput extends z.ZodType = z.ZodType, RunOutput = unknown> extends Omit<RunnableBindingArgs<z.infer<RunInput>, RunOutput>, "config"> {
	name: string;
	description?: string;
	schema: RunInput;
	config?: RunnableConfig;
}
declare class RunnableToolLike<RunInput extends z.ZodType = z.ZodType, RunOutput = unknown> extends RunnableBinding<z.infer<RunInput>, RunOutput> {
	name: string;
	description?: string;
	schema: RunInput;
	constructor(fields: RunnableToolLikeArgs<RunInput, RunOutput>);
	static lc_name(): string;
}
type SerializedLLM = {
	_model: string;
	_type: string;
} & Record<string, any>;
interface BaseLangChainParams {
	verbose?: boolean;
	callbacks?: Callbacks;
	tags?: string[];
	metadata?: Record<string, unknown>;
}
declare abstract class BaseLangChain<RunInput, RunOutput, CallOptions extends RunnableConfig = RunnableConfig> extends Runnable<RunInput, RunOutput, CallOptions> implements BaseLangChainParams {
	/**
	 * Whether to print out response text.
	 */
	verbose: boolean;
	callbacks?: Callbacks;
	tags?: string[];
	metadata?: Record<string, unknown>;
	get lc_attributes(): {
		[key: string]: undefined;
	} | undefined;
	constructor(params: BaseLangChainParams);
}
interface BaseLanguageModelParams extends AsyncCallerParams$1, BaseLangChainParams {
	/**
	 * @deprecated Use `callbacks` instead
	 */
	callbackManager?: CallbackManager;
	cache?: BaseCache | boolean;
}
interface BaseLanguageModelCallOptions extends RunnableConfig {
	/**
	 * Stop tokens to use for this call.
	 * If not provided, the default stop tokens for the model will be used.
	 */
	stop?: string[];
}
type BaseLanguageModelInput = BasePromptValueInterface | string | BaseMessageLike[];
type StructuredOutputMethodOptions<IncludeRaw extends boolean = false> = {
	name?: string;
	method?: "functionCalling" | "jsonMode" | "jsonSchema" | string;
	includeRaw?: IncludeRaw;
	/** Whether to use strict mode. Currently only supported by OpenAI models. */
	strict?: boolean;
};
interface BaseLanguageModelInterface<RunOutput = any, CallOptions extends BaseLanguageModelCallOptions = BaseLanguageModelCallOptions> extends RunnableInterface<BaseLanguageModelInput, RunOutput, CallOptions> {
	get callKeys(): string[];
	generatePrompt(promptValues: BasePromptValueInterface[], options?: string[] | CallOptions, callbacks?: Callbacks): Promise<LLMResult>;
	/**
	 * @deprecated Use .invoke() instead. Will be removed in 0.2.0.
	 */
	predict(text: string, options?: string[] | CallOptions, callbacks?: Callbacks): Promise<string>;
	/**
	 * @deprecated Use .invoke() instead. Will be removed in 0.2.0.
	 */
	predictMessages(messages: BaseMessage[], options?: string[] | CallOptions, callbacks?: Callbacks): Promise<BaseMessage>;
	_modelType(): string;
	_llmType(): string;
	getNumTokens(content: MessageContent): Promise<number>;
	/**
	 * Get the identifying parameters of the LLM.
	 */
	_identifyingParams(): Record<string, any>;
	serialize(): SerializedLLM;
}
declare abstract class BaseLanguageModel<RunOutput = any, CallOptions extends BaseLanguageModelCallOptions = BaseLanguageModelCallOptions> extends BaseLangChain<BaseLanguageModelInput, RunOutput, CallOptions> implements BaseLanguageModelParams, BaseLanguageModelInterface<RunOutput, CallOptions> {
	/**
	 * Keys that the language model accepts as call options.
	 */
	get callKeys(): string[];
	/**
	 * The async caller should be used by subclasses to make any async calls,
	 * which will thus benefit from the concurrency and retry logic.
	 */
	caller: AsyncCaller;
	cache?: BaseCache;
	constructor({ callbacks, callbackManager, ...params }: BaseLanguageModelParams);
	abstract generatePrompt(promptValues: BasePromptValueInterface[], options?: string[] | CallOptions, callbacks?: Callbacks): Promise<LLMResult>;
	/**
	 * @deprecated Use .invoke() instead. Will be removed in 0.2.0.
	 */
	abstract predict(text: string, options?: string[] | CallOptions, callbacks?: Callbacks): Promise<string>;
	/**
	 * @deprecated Use .invoke() instead. Will be removed in 0.2.0.
	 */
	abstract predictMessages(messages: BaseMessage[], options?: string[] | CallOptions, callbacks?: Callbacks): Promise<BaseMessage>;
	abstract _modelType(): string;
	abstract _llmType(): string;
	private _encoding?;
	getNumTokens(content: MessageContent): Promise<number>;
	protected static _convertInputToPromptValue(input: BaseLanguageModelInput): BasePromptValueInterface;
	/**
	 * Get the identifying parameters of the LLM.
	 */
	_identifyingParams(): Record<string, any>;
	/**
	 * Create a unique cache key for a specific call to a specific language model.
	 * @param callOptions Call options for the model
	 * @returns A unique cache key.
	 */
	_getSerializedCacheKeyParametersForCall({ config, ...callOptions }: CallOptions & {
		config?: RunnableConfig;
	}): string;
	/**
	 * @deprecated
	 * Return a json-like object representing this LLM.
	 */
	serialize(): SerializedLLM;
	/**
	 * @deprecated
	 * Load an LLM from a json-like object describing it.
	 */
	static deserialize(_data: SerializedLLM): Promise<BaseLanguageModel>;
	withStructuredOutput?<RunOutput extends Record<string, any> = Record<string, any>>(schema: z.ZodType<RunOutput> | Record<string, any>, config?: StructuredOutputMethodOptions<false>): Runnable<BaseLanguageModelInput, RunOutput>;
	withStructuredOutput?<RunOutput extends Record<string, any> = Record<string, any>>(schema: z.ZodType<RunOutput> | Record<string, any>, config?: StructuredOutputMethodOptions<true>): Runnable<BaseLanguageModelInput, {
		raw: BaseMessage;
		parsed: RunOutput;
	}>;
	/**
	 * Model wrapper that returns outputs formatted to match the given schema.
	 *
	 * @template {BaseLanguageModelInput} RunInput The input type for the Runnable, expected to be the same input for the LLM.
	 * @template {Record<string, any>} RunOutput The output type for the Runnable, expected to be a Zod schema object for structured output validation.
	 *
	 * @param {z.ZodEffects<RunOutput>} schema The schema for the structured output. Either as a Zod schema or a valid JSON schema object.
	 *   If a Zod schema is passed, the returned attributes will be validated, whereas with JSON schema they will not be.
	 * @param {string} name The name of the function to call.
	 * @param {"functionCalling" | "jsonMode"} [method=functionCalling] The method to use for getting the structured output. Defaults to "functionCalling".
	 * @param {boolean | undefined} [includeRaw=false] Whether to include the raw output in the result. Defaults to false.
	 * @returns {Runnable<RunInput, RunOutput> | Runnable<RunInput, { raw: BaseMessage; parsed: RunOutput }>} A new runnable that calls the LLM with structured output.
	 */
	withStructuredOutput?<RunOutput extends Record<string, any> = Record<string, any>>(schema: z.ZodType<RunOutput> | Record<string, any>, config?: StructuredOutputMethodOptions<boolean>): Runnable<BaseLanguageModelInput, RunOutput> | Runnable<BaseLanguageModelInput, {
		raw: BaseMessage;
		parsed: RunOutput;
	}>;
}
interface AIModel extends BaseLanguageModel {
	maxInputTokens?: number;
}
type Tracer = {
	error(message: string, output?: {
		[key: string]: unknown;
	}): Promise<void>;
	get run(): RunTree | undefined;
	get config(): RunnableConfig | undefined;
	success(output: {
		[key: string]: unknown;
	}): Promise<void>;
};
type Tagged<T, Tag extends string> = T & {
	readonly [L in Tag as `Tagged:${L}`]: never;
};
type WriteFn = (artifactPartName: string, toSave: string) => Promise<void>;
type ExistFn = (artifactPartName: string) => Promise<boolean>;
type ReadEntryFn = (artifactPartName: string) => Promise<string>;
type ReadDirFn = (artifactPartName?: string) => Promise<{
	files: string[];
	directories: string[];
}>;
type ReadFn = ReadEntryFn & {
	dir: ReadDirFn;
	exists: ExistFn;
};
type ArtifactName = Tagged<string, "ArtifactName">;
type LoadOtherArtifactFn = <TSchema extends z.ZodTypeAny, TRetValue = z.TypeOf<TSchema>>(artifactKind: Artifact<TSchema>, artifactId: string) => Promise<TRetValue>;
type ArtifactDef<TSchema extends z.ZodTypeAny> = {
	/**
	 * A name that uniquely identifies the kind of artifact that is encapsulated. Some examples of
	 * possible names: 'LwcCode', 'Blueprint', 'WireframeImage', 'AuraCode', etc.
	 *
	 * This string should be filename-friendly, as it will be used for constructing paths when
	 * saving artifact instances to disk (or whatever other storage mechanism is provided). As such,
	 * the `name` should consist only of uppercase and lowercase letters.
	 */
	name: ArtifactName;
	/**
	 * The Zod schema to which all artifact instances will conform. Specifically, if an Applet returns
	 * an artifact from its `generate` routine, that artifact-value must match the corresponding schema.
	 */
	schema: TSchema;
	/**
	 * A function that is called to serialize and persist the artifact to storage. The storage backend
	 * itself is abstracted away from the artifact; calls to the provided `write` function may result
	 * in writes to disk, a POST network call, or persistence in-memory.
	 *
	 * When saving parts of an artifact, `artifactPartName` can be thought of as the key and `toSave`
	 * as the value. `artifactPartName` should be filepath-friendly; when saving to disk, this value
	 * will be used in construction of filepaths where the artifact part is saved. `toSave` can be
	 * any string.
	 */
	save(write: WriteFn, value: TSchema["_output"]): Promise<void>;
	/**
	 * A function that is called to load an artifact from storage and deserialize it into a value that
	 * conforms to the `schema`. The `save` and `load` implementations should be approximate mirror-images
	 * of one another; whatever behavior you write in save should probably have some corresponding logic
	 * in `load`.
	 *
	 * If necessary, it is possible to read entries in a directory; if the backend is not a filesystem,
	 * a basic "directory" structure will be simulated by the `read.dir` call.
	 *
	 * It is also possible for `load` to be recursive. It is not advised but, if necessary, one can
	 * `loadOtherArtifact` as part of the `load` logic and use that loaded artifact value in some way.
	 */
	load(read: ReadFn, id: string, loadOtherArtifact: LoadOtherArtifactFn): Promise<TSchema["_output"]>;
	/**
	 * Whenever a new artifact is created, it needs a unique ID to distinguish it from other artifacts
	 * of the same kind. A default `generateId` implementation is used if one is not explicitly provided
	 * by the `Artifact`. This default implementation will generate a random v4 UUID.
	 */
	generateId?(value: TSchema["_output"]): string;
};
type Artifact<TSchema extends z.ZodTypeAny> = Required<ArtifactDef<TSchema>>;
type ArtifactSchemas<TArtifacts extends Array<Artifact<ZodTypeAny>>> = {
	[K in keyof TArtifacts]: TArtifacts[K] extends Artifact<infer ArtifactSchema> ? ArtifactSchema : never;
};
type ArtifactValues<TArtifacts extends Array<Artifact<ZodTypeAny>>> = {
	[K in keyof TArtifacts]: z.TypeOf<ArtifactSchemas<TArtifacts>[K]>;
};
type OptionalArtifact<T extends z.ZodTypeAny> = Artifact<T> & {
	optional: true;
};
type OnUpdate = () => void;
type Unsubscribe = () => void;
interface Signal<T> {
	get value(): T;
	subscribe(onUpdate: OnUpdate): Unsubscribe;
}
declare abstract class SignalBaseClass<T> implements Signal<T> {
	abstract get value(): T;
	private subscribers;
	subscribe(onUpdate: OnUpdate): () => void;
	protected notify(): void;
}
declare class AppletSignal<AppletState> extends SignalBaseClass<any> {
	_value: AppletState;
	constructor(initialValue: AppletState);
	set value(newValue: AppletState);
	get value(): AppletState;
}
declare enum AppletStateType {
	QUEUED = "AppletQueued",
	INPROGRESS = "AppletInProgress",
	SUCCESS = "AppletSuccess",
	FAILURE = "AppletFailure"
}
interface AppletQueued {
	type: AppletStateType.QUEUED;
}
interface AppletInProgress {
	type: AppletStateType.INPROGRESS;
	progress: number;
}
interface AppletSuccess {
	type: AppletStateType.SUCCESS;
	message: string;
}
interface AppletFailure {
	type: AppletStateType.FAILURE;
	message: string;
}
type AppletState = AppletQueued | AppletInProgress | AppletSuccess | AppletFailure;
type AvailableArtifacts = Map<ArtifactName, string>;
type InvocationState = AppletStateType.SUCCESS | AppletStateType.FAILURE;
type AppletContext = {
	model: AIModel;
	tracer: Tracer;
	availableArtifacts: AvailableArtifacts;
	storage: {
		read: ReadFn;
		write: WriteFn;
	};
};
type Applet<TInputArtifacts extends Array<Artifact<ZodTypeAny>>, TOutputArtifacts extends Array<Artifact<ZodTypeAny>>> = {
	/**
	 * The name of the applet. Must be unique.
	 */
	name: string;
	/**
	 * A one-sentence description of the applet's purpose.
	 */
	description: string;
	/**
	 * A list of categories to which this applet belongs.
	 */
	tags?: string[];
	/**
	 * Defines what the applet expects to receive as input upon invocation.
	 */
	inputs: TInputArtifacts;
	/**
	 * Defines what the applet is intended to generate. This information is not directly exposed
	 * outside of the applet and therefore is not consumed by the orchestration layer. However,
	 * each output artifact that is defined will be implicitly persisted using the `save` mechanism
	 * included in the artifact's definition.
	 */
	outputs: TOutputArtifacts;
	/**
	 * The primary phase of the applet's invocation. Any interactions with LLMs should happen here.
	 * Any interactions with static analysis or other deterministic tools should happen here.
	 * The return value must conform to the `generatedSchema`. A LLM is provided as part of
	 * `AppletContext` and can be used during `generate` if desired.
	 */
	generate(cxt: AppletContext, inputValues: ArtifactValues<TInputArtifacts>): Promise<ArtifactValues<TOutputArtifacts>>;
	/**
	 * The message to be returned to the orchestrator upon successful completion.
	 * This should be descriptive and only include information that the orchestrator may need
	 * to make decisions about subsequent steps.
	 */
	formatSuccess: string;
	/**
	 * While errors are automatically caught and turned into a message for the orchestrator, it
	 * may be desirable for an applet to hand-craft this error message. `formatError` provides
	 * the opportunity to transform a thrown Error's message into something more
	 * suited for consumption by the orchestrator.
	 */
	formatError: string;
};
type LoadArtifactReturnType<Schema extends z.ZodTypeAny, T extends OptionalArtifact<Schema> | Artifact<Schema>> = T extends OptionalArtifact<Schema> ? null | Schema["_output"] : Schema["_output"];
declare abstract class OrchestrationState {
	sessionArtifacts: AvailableArtifacts;
	abstract model: AIModel | null;
	abstract tracer: Tracer | null;
	abstract io: {
		read: ReadFn;
		write: WriteFn;
	};
	invokeAppletDirect<TInputArtifacts extends Array<Artifact<ZodTypeAny>>, TOutputArtifacts extends Array<Artifact<ZodTypeAny>>>(applet: Applet<TInputArtifacts, TOutputArtifacts>, appletStates?: Map<string, AppletSignal<AppletState>>): Promise<{
		message: string;
		outputArtifacts: [
			ArtifactName,
			string
		][];
		invocationState: InvocationState;
	}>;
	invokeApplet<TInputArtifacts extends Array<Artifact<ZodTypeAny>>, TOutputArtifacts extends Array<Artifact<ZodTypeAny>>>(applet: Applet<TInputArtifacts, TOutputArtifacts>, appletStates?: Map<string, AppletSignal<AppletState>>): Promise<string>;
	primeArtifact(artifactName: ArtifactName, artifactId: string): this;
	getArtifactId(artifactName: ArtifactName): string | undefined;
	setArtifactId(artifactName: ArtifactName, artifactId: string): void;
	hasArtifact(artifactKind: Artifact<ZodTypeAny>): boolean;
	loadArtifact<Schema extends z.ZodTypeAny, ArtifactKind extends OptionalArtifact<Schema> | Artifact<Schema>>(artifactKind: ArtifactKind): Promise<LoadArtifactReturnType<Schema, ArtifactKind>>;
	/**
	 * Something like this might be used by the orchestrator to determine what Applet
	 * to invoke next. For example, if the orchestrator knows that it has a Blueprint
	 * but it does not have LwcCode, it can make the choice to invoke the LwcGenerator
	 * applet.
	 */
	getAvailableArtifactNames(): ArtifactName[];
}
type MessageRole = "human" | "ai" | "generic" | "system" | "function" | "tool" | "remove" | "user" | "assistant";
export type Message = string | {
	content: string;
	role?: MessageRole;
};
type RunInferenceFnGeneric<TInferenceOptions extends Record<string, any>> = (prompt: Message[], options?: Partial<TInferenceOptions>) => Promise<string>;
declare const SupportedArtifacts: Record<ArtifactName, ArtifactDef<ZodTypeAny>>;
export type SupportedBundleKind = keyof typeof SupportedArtifacts;
export declare const SupportedBundleKinds: Record<string, string>;
declare const agents: Record<string, any>;
export type AgentName = keyof typeof agents;
export declare enum ModelId {
	Gpt4_20240518_EXAMPLE = "Gpt4_20240518_EXAMPLE"
}
export interface InferenceOptions {
	temperature: number;
	modelId: ModelId;
	maxTokens: number;
	outputJsonSchema: string;
}
export type RunInferenceFn = RunInferenceFnGeneric<InferenceOptions>;
export interface DirectoryEntry {
	name: string;
	isDirectory: boolean;
}
export interface Strategy {
	readBundlePart: <T extends SupportedBundleKind>(artifactKind: T, artifactId: string, partPath: string) => Promise<string>;
	readBundleDir: <T extends SupportedBundleKind>(artifactKind: T, artifactId: string, partPath: string) => Promise<DirectoryEntry[]>;
	bundlePartExists: <T extends SupportedBundleKind>(artifactKind: T, artifactId: string, partPath: string) => Promise<boolean>;
	writeBundlePart: <T extends SupportedBundleKind>(artifactKind: T, artifactId: string, partPath: string, partContent: string) => Promise<void>;
	runInference: RunInferenceFn;
	notify: (identifier: string, details: unknown) => void;
}
type IO = {
	read: ReadFn;
	write: WriteFn;
};
export declare enum StatusCode {
	Success = "Success",
	PartialSuccess = "PartialSuccess",
	Failure = "Failure"
}
interface ExecuteReturnType {
	statusCode: StatusCode;
	messageLog: string[];
}
export declare class LightningGPT extends OrchestrationState {
	#private;
	strategy: Strategy;
	model: AIModel;
	io: IO;
	tracer: Tracer | null;
	constructor(strategy: Strategy);
	execute<T extends AgentName>(agentName: T, artifactId: string): Promise<ExecuteReturnType>;
}

declare namespace z {
	export { AnyZodObject, AnyZodTuple, ArrayCardinality, ArrayKeys, AssertArray, AsyncParseReturnType, BRAND, CatchallInput, CatchallOutput, CustomErrorParams, DIRTY, DenormalizedError, EMPTY_PATH, Effect, EnumLike, EnumValues, ErrorMapCtx, FilterEnum, INVALID, Indices, InnerTypeOfFunction, InputTypeOfTuple, InputTypeOfTupleWithRest, IpVersion, IssueData, KeySchema, NEVER, OK, ObjectPair, OuterTypeOfFunction, OutputTypeOfTuple, OutputTypeOfTupleWithRest, ParseContext, ParseInput, ParseParams, ParsePath, ParsePathComponent, ParseResult, ParseReturnType, ParseStatus, PassthroughType, PreprocessEffect, Primitive, ProcessedCreateParams, RawCreateParams, RecordType, Refinement, RefinementCtx, RefinementEffect, SafeParseError, SafeParseReturnType, SafeParseSuccess, Scalars, SomeZodObject, StringValidation, SuperRefinement, SyncParseReturnType, TransformEffect, TypeOf, TypeOf as infer, UnknownKeysParam, Values, Writeable, ZodAny, ZodAnyDef, ZodArray, ZodArrayDef, ZodBigInt, ZodBigIntCheck, ZodBigIntDef, ZodBoolean, ZodBooleanDef, ZodBranded, ZodBrandedDef, ZodCatch, ZodCatchDef, ZodCustomIssue, ZodDate, ZodDateCheck, ZodDateDef, ZodDefault, ZodDefaultDef, ZodDiscriminatedUnion, ZodDiscriminatedUnionDef, ZodDiscriminatedUnionOption, ZodEffects, ZodEffects as ZodTransformer, ZodEffectsDef, ZodEnum, ZodEnumDef, ZodError, ZodErrorMap, ZodFirstPartySchemaTypes, ZodFirstPartyTypeKind, ZodFormattedError, ZodFunction, ZodFunctionDef, ZodIntersection, ZodIntersectionDef, ZodInvalidArgumentsIssue, ZodInvalidDateIssue, ZodInvalidEnumValueIssue, ZodInvalidIntersectionTypesIssue, ZodInvalidLiteralIssue, ZodInvalidReturnTypeIssue, ZodInvalidStringIssue, ZodInvalidTypeIssue, ZodInvalidUnionDiscriminatorIssue, ZodInvalidUnionIssue, ZodIssue, ZodIssueBase, ZodIssueCode, ZodIssueOptionalMessage, ZodLazy, ZodLazyDef, ZodLiteral, ZodLiteralDef, ZodMap, ZodMapDef, ZodNaN, ZodNaNDef, ZodNativeEnum, ZodNativeEnumDef, ZodNever, ZodNeverDef, ZodNonEmptyArray, ZodNotFiniteIssue, ZodNotMultipleOfIssue, ZodNull, ZodNullDef, ZodNullable, ZodNullableDef, ZodNullableType, ZodNumber, ZodNumberCheck, ZodNumberDef, ZodObject, ZodObjectDef, ZodOptional, ZodOptionalDef, ZodOptionalType, ZodParsedType, ZodPipeline, ZodPipelineDef, ZodPromise, ZodPromiseDef, ZodRawShape, ZodReadonly, ZodReadonlyDef, ZodRecord, ZodRecordDef, ZodSet, ZodSetDef, ZodString, ZodStringCheck, ZodStringDef, ZodSymbol, ZodSymbolDef, ZodTooBigIssue, ZodTooSmallIssue, ZodTuple, ZodTupleDef, ZodTupleItems, ZodType, ZodType as Schema, ZodType as ZodSchema, ZodTypeAny, ZodTypeDef, ZodUndefined, ZodUndefinedDef, ZodUnion, ZodUnionDef, ZodUnionOptions, ZodUnknown, ZodUnknownDef, ZodUnrecognizedKeysIssue, ZodVoid, ZodVoidDef, addIssueToContext, anyType as any, arrayOutputType, arrayType as array, baseObjectInputType, baseObjectOutputType, bigIntType as bigint, booleanType as boolean, coerce, custom, dateType as date, datetimeRegex, deoptional, discriminatedUnionType as discriminatedUnion, effectsType as effect, effectsType as transformer, enumType as enum, errorMap as defaultErrorMap, functionType as function, getErrorMap, getParsedType, inferFlattenedErrors, inferFormattedError, input, instanceOfType as instanceof, intersectionType as intersection, isAborted, isAsync, isDirty, isValid, late, lazyType as lazy, literalType as literal, makeIssue, mapType as map, mergeTypes, nanType as nan, nativeEnumType as nativeEnum, neverType as never, noUnrecognized, nullType as null, nullableType as nullable, numberType as number, objectInputType, objectOutputType, objectType as object, objectUtil, oboolean, onumber, optionalType as optional, ostring, output, pipelineType as pipeline, preprocessType as preprocess, promiseType as promise, quotelessJson, recordType as record, setErrorMap, setType as set, strictObjectType as strictObject, stringType as string, symbolType as symbol, tupleType as tuple, typeToFlattenedError, typecast, undefinedType as undefined, unionType as union, unknownType as unknown, util, voidType as void };
}

export {};
