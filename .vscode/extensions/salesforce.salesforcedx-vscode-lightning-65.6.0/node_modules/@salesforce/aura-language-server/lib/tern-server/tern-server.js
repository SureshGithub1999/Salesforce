"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.onSignatureHelp = exports.onReferences = exports.onDefinition = exports.onTypeDefinition = exports.onHover = exports.onCompletion = exports.delFile = exports.addFile = exports.startServer = void 0;
const fs_1 = __importStar(require("fs"));
const tern = __importStar(require("../tern/lib/tern"));
const path_1 = __importDefault(require("path"));
const util = __importStar(require("util"));
const infer = __importStar(require("../tern/lib/infer"));
const line_column_1 = __importDefault(require("line-column"));
const string_util_1 = require("./string-util");
const vscode_uri_1 = __importDefault(require("vscode-uri"));
const browser_json_1 = __importDefault(require("../tern/defs/browser.json"));
const ecmascript_json_1 = __importDefault(require("../tern/defs/ecmascript.json"));
const utils_1 = require("@salesforce/lightning-lsp-common/lib/utils");
let theRootPath;
let ternServer;
let asyncTernRequest;
let asyncFlush;
const defaultConfig = {
    ecmaVersion: 6,
    stripCRs: false,
    disableLoadingLocal: true,
    verbose: true,
    debug: true,
    async: true,
    dependencyBudget: 20000,
};
const auraInstanceLastSort = (a, b) => a.endsWith('AuraInstance.js') === b.endsWith('AuraInstance.js') ? 0 : a.endsWith('AuraInstance.js') ? 1 : -1;
async function loadPlugins() {
    await Promise.resolve().then(() => __importStar(require('./tern-aura')));
    await Promise.resolve().then(() => __importStar(require('../tern/plugin/modules')));
    await Promise.resolve().then(() => __importStar(require('../tern/plugin/doc_comment')));
    return {
        aura: true,
        modules: true,
        doc_comment: true,
    };
}
/** recursively search upward from the starting diretory.  Handling the is it a monorepo vs. packaged vs. bundled code  */
const searchAuraResourcesPath = (dir) => {
    console.log(`aura-language-server: searching for resources/aura in ${dir}`);
    if (fs_1.default.existsSync(path_1.default.join(dir, 'resources', 'aura'))) {
        console.log('found resources/aura in', dir);
        return path_1.default.join(dir, 'resources', 'aura');
    }
    if (path_1.default.dirname(dir) === dir) {
        throw new Error('No resources/aura directory found');
    }
    return searchAuraResourcesPath(path_1.default.dirname(dir));
};
async function ternInit() {
    await asyncTernRequest({
        query: {
            type: 'ideInit',
            unloadDefs: true,
            // shouldFilter: true,
        },
    });
    const resources = searchAuraResourcesPath(__dirname);
    (await fs_1.default.promises.readdir(resources, { withFileTypes: true, recursive: true }))
        .filter((dirent) => dirent.isFile() && dirent.name.endsWith('.js'))
        .map((dirent) => path_1.default.join(dirent.parentPath, dirent.name))
        // special handling for hacking one snowflake file that needs to go last
        .sort(auraInstanceLastSort)
        .map((file) => ({
        file,
        contents: file.endsWith('AuraInstance.js')
            ? // and the snowflake needs to me modified
                (0, fs_1.readFileSync)(file, 'utf-8').concat(`\nwindow['$A'] = new AuraInstance();\n`)
            : (0, fs_1.readFileSync)(file, 'utf-8'),
    }))
        .map(({ file, contents }) => ternServer.addFile(file, contents));
}
const init = (0, utils_1.memoize)(ternInit);
async function startServer(rootPath, wsroot) {
    const defs = [browser_json_1.default, ecmascript_json_1.default];
    const plugins = await loadPlugins();
    const config = {
        ...defaultConfig,
        defs,
        plugins,
        projectDir: rootPath,
        getFile(filename, callback) {
            // note: this isn't invoked
            fs_1.default.readFile(path_1.default.resolve(rootPath, filename), 'utf8', callback);
        },
    };
    theRootPath = wsroot;
    ternServer = new tern.Server(config);
    asyncTernRequest = util.promisify(ternServer.request.bind(ternServer));
    asyncFlush = util.promisify(ternServer.flush.bind(ternServer));
    init();
    return ternServer;
}
exports.startServer = startServer;
function lsp2ternPos({ line, character }) {
    return { line, ch: character };
}
function tern2lspPos({ line, ch }) {
    return { line, character: ch };
}
function fileToUri(file) {
    if (path_1.default.isAbsolute(file)) {
        return vscode_uri_1.default.file(file).toString();
    }
    else {
        return vscode_uri_1.default.file(path_1.default.join(theRootPath, file)).toString();
    }
}
function uriToFile(uri) {
    const parsedUri = vscode_uri_1.default.parse(uri);
    // paths from tests can be relative or absolute
    return parsedUri.scheme ? parsedUri.fsPath : uri;
}
function tern2lspRange({ start, end }) {
    return {
        start: tern2lspPos(start),
        end: tern2lspPos(end),
    };
}
function tern2lspLocation({ file, start, end }) {
    return {
        uri: fileToUri(file),
        range: tern2lspRange({ start, end }),
    };
}
async function ternRequest(event, type, options = {}) {
    return await asyncTernRequest({
        query: {
            type,
            file: uriToFile(event.textDocument.uri),
            end: lsp2ternPos(event.position),
            lineCharPositions: true,
            ...options,
        },
    });
}
const addFile = (event) => {
    const { document } = event;
    ternServer.addFile(uriToFile(document.uri), document.getText());
};
exports.addFile = addFile;
const delFile = (close) => {
    const { document } = close;
    ternServer.delFile(uriToFile(document.uri));
};
exports.delFile = delFile;
const onCompletion = async (completionParams) => {
    try {
        await init();
        await asyncFlush();
        const { completions } = await ternRequest(completionParams, 'completions', {
            types: true,
            docs: true,
            depths: true,
            guess: true,
            origins: true,
            urls: true,
            expandWordForward: true,
            caseInsensitive: true,
        });
        const items = completions.map((completion) => {
            let kind = 18;
            if (completion.type && completion.type.startsWith('fn')) {
                kind = 3;
            }
            return {
                documentation: completion.doc,
                detail: completion.type,
                label: completion.name,
                kind,
            };
        });
        return {
            isIncomplete: true,
            items,
        };
    }
    catch (e) {
        if (e.message && e.message.startsWith('No type found')) {
            return;
        }
        return {
            isIncomplete: true,
            items: [],
        };
    }
};
exports.onCompletion = onCompletion;
const onHover = async (textDocumentPosition) => {
    try {
        await init();
        await asyncFlush();
        const info = await ternRequest(textDocumentPosition, 'type');
        const out = [];
        out.push(`${info.exprName || info.name}: ${info.type}`);
        if (info.doc) {
            out.push(info.doc);
        }
        if (info.url) {
            out.push(info.url);
        }
        return { contents: out };
    }
    catch (e) {
        if (e.message && e.message.startsWith('No type found')) {
            return;
        }
    }
};
exports.onHover = onHover;
const onTypeDefinition = async (textDocumentPosition) => {
    const info = await ternRequest(textDocumentPosition, 'type');
    if (info && info.origin) {
        const contents = fs_1.default.readFileSync(info.origin, 'utf-8');
        const endCol = new line_column_1.default(contents, { origin: 0 }).fromIndex(contents.length - 1);
        return {
            uri: fileToUri(info.origin),
            range: {
                start: {
                    line: 0,
                    character: 0,
                },
                end: {
                    line: endCol.line,
                    character: endCol.col,
                },
            },
        };
    }
};
exports.onTypeDefinition = onTypeDefinition;
const onDefinition = async (textDocumentPosition) => {
    try {
        await init();
        await asyncFlush();
        const { file, start, end } = await ternRequest(textDocumentPosition, 'definition', { preferFunction: false, doc: false });
        if (file) {
            const responseURI = fileToUri(file);
            // check to see if the request position is inside the response object
            const requestURI = textDocumentPosition.textDocument.uri;
            if (responseURI === requestURI &&
                start.line === textDocumentPosition.position.line &&
                textDocumentPosition.position.character >= start.ch &&
                textDocumentPosition.position.character <= end.ch) {
                return (0, exports.onTypeDefinition)(textDocumentPosition);
            }
            if (file === 'Aura') {
                return;
            }
            else if (file.indexOf('/resources/aura/') >= 0) {
                const slice = file.slice(file.indexOf('/resources/aura/'));
                const real = path_1.default.join(__dirname, '..', '..', slice);
                return {
                    uri: vscode_uri_1.default.file(real).toString(),
                    range: tern2lspRange({ start, end }),
                };
            }
            return tern2lspLocation({ file, start, end });
        }
    }
    catch (e) {
        if (e.message && e.message.startsWith('No type found')) {
            return;
        }
    }
};
exports.onDefinition = onDefinition;
const onReferences = async (reference) => {
    await init();
    await asyncFlush();
    const { refs } = await ternRequest(reference, 'refs');
    if (refs && refs.length > 0) {
        return refs.map((ref) => tern2lspLocation(ref));
    }
};
exports.onReferences = onReferences;
const onSignatureHelp = async (signatureParams) => {
    const { position, textDocument: { uri }, } = signatureParams;
    try {
        await init();
        await asyncFlush();
        const files = ternServer.files;
        const fileName = ternServer.normalizeFilename(uriToFile(uri));
        const file = files.find((f) => f.name === fileName);
        const contents = file.text;
        const offset = new line_column_1.default(contents, { origin: 0 }).toIndex(position.line, position.character);
        const left = (0, string_util_1.findPreviousLeftParan)(contents, offset - 1);
        const word = (0, string_util_1.findPreviousWord)(contents, left);
        const info = await asyncTernRequest({
            query: {
                type: 'type',
                file: file.name,
                end: word.start,
                docs: true,
            },
        });
        const commas = (0, string_util_1.countPreviousCommas)(contents, offset - 1);
        const cx = ternServer.cx;
        let parsed;
        infer.withContext(cx, () => {
            const parser = new infer.def.TypeParser(info.type);
            parsed = parser.parseType(true);
        });
        const params = parsed.args.map((arg, index) => {
            const type = arg.getType();
            return {
                label: parsed.argNames[index],
                documentation: type.toString() + '\n' + (type.doc || ''),
            };
        });
        const sig = {
            label: parsed.argNames[commas] || 'unknown param',
            documentation: `${info.exprName || info.name}: ${info.doc}`,
            parameters: params,
        };
        const sigs = {
            signatures: [sig],
            activeSignature: 0,
            activeParameter: commas,
        };
        return sigs;
    }
    catch (e) {
        // ignore
    }
};
exports.onSignatureHelp = onSignatureHelp;
//# sourceMappingURL=tern-server.js.map