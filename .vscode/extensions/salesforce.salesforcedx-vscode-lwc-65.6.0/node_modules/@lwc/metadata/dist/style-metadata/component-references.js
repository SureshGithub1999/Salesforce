'use strict';

var sfdcCompilerUtils = require('@lwc/sfdc-compiler-utils');
var postcssSelector = require('postcss-selector-parser');
var utils = require('../shared/utils.js');
var utils$1 = require('./utils.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var postcssSelector__default = /*#__PURE__*/_interopDefaultCompat(postcssSelector);

// Copyright (c) 2022, Salesforce, Inc.,
// All rights reserved.
// For full license text, see the LICENSE.txt file
function isCustomElementSelector(tag) {
    return tag.includes('-');
}
function getSelectorReferences({ selector, source }, offset, namespaceMapping) {
    const references = [];
    const processor = postcssSelector__default.default();
    const root = processor.astSync(selector, { lossless: true });
    root.walkTags((node) => {
        // [W-7479930] Workaround issue where An+B CSS micro-syntax is incorrectly parsed by
        // postcss-selector-parser: https://github.com/postcss/postcss-selector-parser/issues/14.
        // Currently `3n-1` inside `:nth-last-of-type(3n-1)` is wrongly treated as a tag selector.
        // [W-14924871] Workaround as ::part() pseudo element attributes are being processed as tags
        if (postcssSelector__default.default.isSelector(node.parent) &&
            postcssSelector__default.default.isPseudo(node.parent.parent) &&
            (node.parent.parent.value.startsWith(':nth') ||
                node.parent.parent.value === '::part' ||
                node.parent.parent.value === '::highlight')) {
            return;
        }
        const tagName = node.value;
        if (!isCustomElementSelector(tagName)) {
            return;
        }
        const moduleName = utils.tagNameToComponentName(tagName);
        const ref = {
            name: utils.tagNameToComponentName(tagName),
            tagName,
            type: 'external',
            locations: [utils$1.getReferenceLocation(source, offset + node.sourceIndex, tagName.length)],
        };
        const namespacedName = sfdcCompilerUtils.getNamespacedIdForResource(moduleName, namespaceMapping);
        if (!utils.isUndefined(namespacedName)) {
            ref.namespacedName = namespacedName;
        }
        references.push(ref);
    });
    return references;
}
function collectComponentReferences(result, root, namespaceMapping) {
    const references = new Map();
    root.walkRules((rule) => {
        const selectorOffset = rule.source.start.offset;
        const ruleReferences = getSelectorReferences(rule, selectorOffset, namespaceMapping);
        for (const referenceInRule of ruleReferences) {
            const { tagName } = referenceInRule;
            let reference = references.get(tagName);
            if (utils.isUndefined(reference)) {
                reference = referenceInRule;
                references.set(tagName, reference);
            }
            else {
                reference.locations.push(...referenceInRule.locations);
            }
        }
    });
    result.componentReferences.push(...references.values());
}

exports.collectComponentReferences = collectComponentReferences;
//# sourceMappingURL=component-references.js.map
