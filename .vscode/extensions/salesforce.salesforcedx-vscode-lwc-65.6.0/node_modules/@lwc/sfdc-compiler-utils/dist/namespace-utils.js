"use strict";
// Copyright (c) 2022, Salesforce, Inc.,
// All rights reserved.
// For full license text, see the LICENSE.txt file
Object.defineProperty(exports, "__esModule", { value: true });
exports.SITE_LOCAL_NAMESPACE = exports.DEFAULT_SALESFORCE_NAMESPACE = void 0;
exports.getNamespacedIdForType = getNamespacedIdForType;
exports.getNamespacedIdForResource = getNamespacedIdForResource;
exports.containsExplicitNamespace = containsExplicitNamespace;
const SALESFORCE_IMPORT_PREFIX = '@salesforce/';
exports.DEFAULT_SALESFORCE_NAMESPACE = 'c';
exports.SITE_LOCAL_NAMESPACE = 'site';
/**
 * @param: moduleName - 'c.label'
 * @param: moduleType - 'label'
 * @param: namespaceMapping<sting, string> - { c: 'ns' }
 *
 * @return: string - 'label/ns.label'
 */
function getNamespacedIdForType(moduleName, moduleType, namespaceMapping) {
    validateParameters(moduleName, namespaceMapping);
    let updatedModuleName;
    if (moduleType && moduleType !== 'module') {
        updatedModuleName = getSalesforceNamespacedModule(moduleName, moduleType, namespaceMapping);
    }
    else {
        updatedModuleName = getStandardNamespacedModule(moduleName, namespaceMapping);
    }
    return updatedModuleName;
}
/**
 * Retrieve and alias @salesforce scoped resource id. If provided resource doesn't start
 * with @salesforce prefix, the resource is treated as a regular module
 *
 * @param: moduleName - '@salesforce/label/c.label'
 * @param: namespaceMapping<sting, string> - { c: 'ns' }
 *
 * @return: string - 'ns.label'
 */
function getNamespacedIdForResource(moduleName, namespaceMapping) {
    validateParameters(moduleName, namespaceMapping);
    let updatedModuleName;
    if (moduleName.startsWith(SALESFORCE_IMPORT_PREFIX)) {
        const [prefix, type, value] = moduleName.split('/');
        const updatedModuleId = getSalesforceNamespacedModule(value, type, namespaceMapping);
        if (updatedModuleId) {
            updatedModuleName = [prefix, type, updatedModuleId].join('/');
        }
    }
    else {
        const updateModuleId = getStandardNamespacedModule(moduleName, namespaceMapping);
        if (updateModuleId) {
            updatedModuleName = updateModuleId;
        }
    }
    return updatedModuleName;
}
function getSalesforceNamespacedModule(value, type, namespaceMapping) {
    if (!value) {
        return undefined;
    }
    let existingNamespace;
    let newNamespace;
    let parts;
    const defaultTargetValue = namespaceMapping[exports.DEFAULT_SALESFORCE_NAMESPACE];
    switch (type) {
        // @salesforce/label/c.label1 -> @salesforce/label/namespace.label1
        case 'label':
            parts = value.split('.');
            // filter out invalid format:
            // @salesforce/label/c..label
            if (parts.some((p) => !p)) {
                return undefined;
            }
            existingNamespace = parts[0];
            // no namespace - @salesforce/label/label1
            if (parts.length === 1) {
                return undefined;
            }
            newNamespace = namespaceMapping[existingNamespace];
            return newNamespace
                ? value.replace(`${existingNamespace}.`, `${newNamespace}.`)
                : value;
        // @salesforce/resourceUrl/resource1 -> @salesforce/resourceUrl/namespace__resource1
        // @salesforce/contentAssetUrl/resource1 -> @salesforce/contentAssetUrl/namespace__resource1
        // @salesforce/customPermission/resource1 -> @salesforce/customPermission/namespace__resource1
        // @salesforce/komaci/resource1 -> @salesforce/komaci/namespace__resource1
        case 'resourceUrl':
        case 'contentAssetUrl':
        case 'customPermission':
        case 'komaci':
            parts = value.split('__');
            // filter out invalid format:
            if (parts.some((p) => !p)) {
                return undefined;
            }
            if (parts.length === 1) {
                return defaultTargetValue && `${defaultTargetValue}__${value}`;
            }
            existingNamespace = parts[0];
            // @salesforce/resourceUrl/namespace__resource1
            newNamespace = namespaceMapping[existingNamespace];
            return newNamespace
                ? value.replace(`${existingNamespace}__`, `${newNamespace}__`)
                : value;
        // Standard messageChannels should have a namespace, e.g. @salesforce/messageChannel/standardNs_messageChannel1
        // Undefined behavior for a missing "__c" suffix (indicating custom) and a missing namespace
        // @salesforce/messageChannel/messageChannel1 -> undefined
        // @salesforce/messageChannel/messageChannel1__c -> @salesforce/messageChannel/namespace__messageChannel1__c
        case 'messageChannel':
            parts = value.split('__');
            // filter out invalid format: @salesforce/messageChannel/messageChannel1
            if (parts.length === 1 || parts.some((p) => !p)) {
                return undefined;
            }
            if (value.endsWith('__c') && parts.length === 2) {
                return defaultTargetValue && `${defaultTargetValue}__${value}`;
            }
            existingNamespace = parts[0];
            // @salesforce/messageChannel/namespace__messageChannel1
            newNamespace = namespaceMapping[existingNamespace];
            return newNamespace
                ? value.replace(`${existingNamespace}__`, `${newNamespace}__`)
                : value;
        // apexContinuation is the same as apex
        // @salesforce/apexContinuation/MyClass.methodA -> @salesforce/apexContinuation/acme.MyClass.methodA
        // @salesforce/apex/MyClass.methodA -> @salesforce/apex/acme.MyClass.methodA
        case 'apexContinuation':
        case 'apex':
        case 'featureFlag':
            // We detect if the apex reference already contains the namespace by checking the number of parts in its
            // reference. If the namespace is present the value would have the following from <ns>.<class>.<method>
            // otherwise it would be <class>.<method>.
            parts = value.split('.');
            // filter out invalid format:
            // @salesforce/apex/MyClass
            // @salesforce/apex/MyClass..methodA
            if (parts.length === 1 || parts.some((p) => !p)) {
                return undefined;
            }
            // @salesforce/apex/MyClass.method -> missing namespace
            if (parts.length === 2) {
                return defaultTargetValue && `${defaultTargetValue}.${value}`;
            }
            existingNamespace = parts[0];
            newNamespace = namespaceMapping[existingNamespace];
            return newNamespace
                ? value.replace(`${existingNamespace}.`, `${newNamespace}.`)
                : value;
        // @salesforce/schema/CustomObject1__c -> @salesforce/schema/acme__CustomObject1__c
        // @salesforce/schema/Account.CustomField__c -> @salesforce/schema/Account.acme__CustomField__c
        // @salesforce/schema/Account.Relationship__r.CustomField__c ->
        // -> @salesforce/schema/Account.acme__Relationship__r.acme__CustomField__c
        case 'schema': {
            // For each object, field and relationship that is part of the module name, if it is custom and has no
            // namespace, we need to add the target namespace.
            const schemaParts = value.split('.');
            const remappedParts = schemaParts.map((part) => {
                const isCustom = part.endsWith('__c') || part.endsWith('__r');
                if (!isCustom) {
                    return part;
                }
                parts = part.split('__');
                // @salesforce/schema/c____CustomObject1
                if (parts.some((p) => !p)) {
                    return undefined;
                }
                const isNamespaced = parts.length > 2;
                // @salesforce/schema/CustomObject1__c
                if (!isNamespaced) {
                    return defaultTargetValue && `${defaultTargetValue}__${part}`;
                }
                // @salesforce/schema/acme__CustomObject1__c
                existingNamespace = parts[0];
                newNamespace = namespaceMapping[existingNamespace];
                // replace only if new mapping exists. ex: acme -> newAcme
                return newNamespace
                    ? part.replace(`${existingNamespace}__`, `${newNamespace}__`)
                    : part;
            });
            // return undefined if any of the parts were not successfully remapped
            return remappedParts.some((p) => !p) ? undefined : remappedParts.join('.');
        }
        // noop
        case 'accessCheck':
        case 'client':
        case 'community':
        case 'cssvars':
        case 'gate':
        case 'i18n':
        case 'internal':
        case 'metric':
        case 'site':
        case 'slds':
        case 'user':
        case 'userPermission':
        case 'webstore':
        case 'lds':
            return undefined;
        default:
            throw new Error(`Failed to apply namespace mapping to "${value}" due to unknown @salesforce type ${type}.`);
    }
}
function getStandardNamespacedModule(moduleName, namespaceMapping) {
    // module format expected to be in the following format: c/utils
    const parts = moduleName.split('/');
    // assert no empty values
    if (parts.some((p) => !p)) {
        return undefined;
    }
    const original = parts[0];
    const target = namespaceMapping[original];
    return target ? moduleName.replace(`${original}/`, `${target}/`) : undefined;
}
function validateParameters(moduleName, namespaceMapping) {
    if (!moduleName) {
        throw new Error(`Failed to apply namespace mapping to "${moduleName}". Missing required "moduleName" parameter`);
    }
    if (!namespaceMapping) {
        throw new Error(`Failed to apply namespace mapping to "${moduleName}". Missing required "namespaceMapping" parameter`);
    }
}
/**
 * This routine is meant to flag when a custom component, in a managed namespace, is using a
 * namespaced module identifier to reference another resource from the same namespace as itself.
 * The guidance is that custom components always reference their own resources using "c" namespace. When
 * they are packaged and installed in a subscriber org, the platform will apply namespace mapping to
 * the module identifier, without having to change the namespace identifiers in source code.
 * For example:
 * c:foo -> A custom component in unmanaged package
 * <template>
 *      <nsJames-bar></nsJames-bar> <!-- Allowed -->
 *      <c-bar></c-bar> <!-- Allowed -->
 * </template>
 *
 * nsJames:foo -> A custom component in a managed package
 * <template>
 *      <nsJames-bar></nsJames-bar> <!-- Not Allowed -->
 *      <c-bar></c-bar> <!-- Allowed -->
 * </template>
 *
 * site:foo -> A site local component(no packaging allowed for these yet)
 * <template>
 *     <c-bar></c-bar> <!-- Allowed -->
 *     <nsJames-bar></nsJames-bar> <!-- Allowed -->
 *     <site:baz></site:baz> <!-- Allowed -->
 * </template>
 *
 * @param value The module identifier of the reference
 * @param type Reference type
 * @param explicitNamespace The namespace of the LWC which contains the reference
 * @returns
 */
function containsExplicitNamespace(value, type, explicitNamespace) {
    if (!value || !type || !explicitNamespace) {
        throw new Error(`Failed to check explicit namespace usage.` +
            `Expected string values for "value", "type", and "explicitNamespace" parameters, ` +
            `received "${value}," "${type}", "${explicitNamespace}".`);
    }
    // nothing to match when default namespace is supplied
    if (explicitNamespace === exports.DEFAULT_SALESFORCE_NAMESPACE) {
        return false;
    }
    let isExplicitNamespaceUsed = false;
    switch (type) {
        case 'component':
            // "site" namespace can be used in site local(aka Code Behind) component reference in template
            if (explicitNamespace === exports.SITE_LOCAL_NAMESPACE) {
                return false;
            }
            // lowercase incoming namespace value because template references are always lowercased
            isExplicitNamespaceUsed = value.startsWith(`${explicitNamespace.toLocaleLowerCase()}-`);
            break;
        case 'module':
            // "site" namespace can be used in site local(aka Code Behind) component reference in js
            if (explicitNamespace === exports.SITE_LOCAL_NAMESPACE) {
                return false;
            }
            isExplicitNamespaceUsed = value.startsWith(`${explicitNamespace}/`);
            break;
        // @salesforce/label/c.label1 -> @salesforce/label/namespace.label1
        case 'label':
            isExplicitNamespaceUsed = value.startsWith(`${explicitNamespace}.`);
            break;
        // @salesforce/schema/Account.CustomField__c -> @salesforce/schema/Account.acme__CustomField__c
        // @salesforce/schema/Account.acme__Relationship__r.acme__CustomField__c
        // @salesforce/resourceUrl/resource1 -> @salesforce/resourceUrl/namespace__resource1
        // @salesforce/contentAssetUrl/asset -> @salesforce/contentAssetUrl/nsC__asset;
        // @salesforce/customPermission/perm -> @salesforce/customPermission/namespace__perm;
        // @salesforce/komaci/resource1 -> @salesforce/komaci/namespace__resource1
        // @salesforce/messageChannel/messageChannel__c -> @salesforce/messageChannel/namespace__messageChannel__c;
        case 'schema':
        case 'resourceUrl':
        case 'contentAssetUrl':
        case 'customPermission':
        case 'komaci':
        case 'messageChannel':
            isExplicitNamespaceUsed = value.includes(`${explicitNamespace}__`);
            break;
        // @salesforce/apexContinuation/MyClass.methodA -> @salesforce/apexContinuation/acme.MyClass.methodA
        // @salesforce/apex/MyClass.methodA -> @salesforce/apex/acme.MyClass.methodA
        // The original resource type is 'apex', however, when we collect the reference
        // we always mark it as an apexMethod.
        case 'apexContinuation':
        case 'apexMethod':
        case 'featureFlag': {
            // If the namespace is present the value would have the following form <ns>.<class>.<method>
            // otherwise it would be <class>.<method>.
            const parts = value.split('.');
            if (parts.length === 3) {
                isExplicitNamespaceUsed = parts[0] === explicitNamespace;
            }
            break;
        }
        // following resources are never namespaced
        case 'client':
        case 'cssvars':
        case 'gate':
        case 'i18n':
        case 'metric':
        case 'user':
        case 'community':
        case 'site':
        case 'internal':
        case 'userPermission':
        case 'webstore':
            break;
        default:
            throw new TypeError(`Unsupported reference type ${type}.`);
    }
    return isExplicitNamespaceUsed;
}
//# sourceMappingURL=namespace-utils.js.map