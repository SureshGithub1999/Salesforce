"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const template_compiler_1 = __importDefault(require("@lwc/template-compiler"));
const path_1 = __importDefault(require("path"));
const vscode_languageserver_1 = require("vscode-languageserver");
const vscode_uri_1 = require("vscode-uri");
const constants_1 = require("../constants");
var DiagnosticLevel;
(function (DiagnosticLevel) {
    /** Unexpected error, parsing error, bundling error */
    DiagnosticLevel[DiagnosticLevel["Fatal"] = 0] = "Fatal";
    /** Linting error with error level, invalid external reference, invalid import, invalid transform */
    DiagnosticLevel[DiagnosticLevel["Error"] = 1] = "Error";
    /** Linting error with warning level, usage of an API to be deprecated */
    DiagnosticLevel[DiagnosticLevel["Warning"] = 2] = "Warning";
    /** Logging messages */
    DiagnosticLevel[DiagnosticLevel["Log"] = 3] = "Log";
})(DiagnosticLevel || (DiagnosticLevel = {}));
const LEVEL_MAPPING = new Map([
    [DiagnosticLevel.Log, vscode_languageserver_1.DiagnosticSeverity.Information],
    [DiagnosticLevel.Warning, vscode_languageserver_1.DiagnosticSeverity.Warning],
    [DiagnosticLevel.Error, vscode_languageserver_1.DiagnosticSeverity.Error],
    [DiagnosticLevel.Fatal, vscode_languageserver_1.DiagnosticSeverity.Error],
]);
const TYPOS = ['<lighting-', '<lightening-', '<lihgtning-'];
function toRange(textDocument, start, length) {
    return vscode_languageserver_1.Range.create(textDocument.positionAt(start), textDocument.positionAt(start + length));
}
function lintTypos(document) {
    const source = document.getText();
    const lines = source.split(/\r?\n/g);
    const errors = [];
    lines.forEach((line, idx) => {
        TYPOS.forEach((typo) => {
            const idxTypo = line.indexOf(typo);
            if (idxTypo > -1) {
                errors.push({
                    range: {
                        start: { line: idx, character: idxTypo },
                        end: { line: idx, character: idxTypo + typo.length },
                    },
                    message: `${typo} is not a valid namespace, sure you didn't mean "<lightning-"?`,
                    severity: LEVEL_MAPPING.get(DiagnosticLevel.Error),
                    source: constants_1.DIAGNOSTIC_SOURCE,
                });
            }
        });
    });
    return errors;
}
function lintLwcMarkup(document) {
    const source = document.getText();
    const file = vscode_uri_1.URI.file(document.uri).fsPath;
    const filePath = path_1.default.parse(file);
    const fileName = filePath.base;
    const { warnings } = (0, template_compiler_1.default)(source, fileName, {});
    let warningsLwc = warnings.map((warning) => {
        const { start = 0, length = 0 } = warning.location || { start: 0, length: 0 };
        return {
            range: toRange(document, start, length),
            message: warning.message,
            severity: LEVEL_MAPPING.get(warning.level),
            source: constants_1.DIAGNOSTIC_SOURCE,
        };
    });
    const warningsTypos = lintTypos(document);
    warningsLwc = warningsLwc.concat(warningsTypos);
    return warningsLwc;
}
exports.default = lintLwcMarkup;
//# sourceMappingURL=linter.js.map